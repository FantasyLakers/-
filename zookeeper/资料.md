zookeeper



1、什么是zookeeper
zookeeper是一个分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务。分布式应用程序可以基于zookeeper实现数据发布与订阅、负载均衡、命名服务、分布式协调与通知、集群管理、Leader选举、分布式锁、分布式队列等功能。
目标：
	a.高性能：zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，尤其适用于以读为主的应用场景。
	b.高可用：zookeeper一般以集群的方式对外提供服务，每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都相互保持通信。只要集群中超过一半的机器都能正常工作，那么整个集群都能正常对外服务。
	c.严格顺序访问：对于来自客户端的每个更新请求，zookeeper都会分配一个全局唯一的递增编号，整个编号反映了所有事务操作的先后顺序。
特点
	a.顺序一致性：从同一个客户端发起的请求，最终会严格按照其发送顺序进入zookeeper中。
	b.原子性：所有请求的响应结果在整个分布式集群环境中具备原子性，即要么整个集群中所有机器都成功的处理了某个请求，要么就都没有处理。
	c.单一性：无论客户端连接到zookeeper集群中的哪个服务器，每个客户端所看到的服务端模型都是一致的。
	d.可靠性：一旦服务端数据的状态发生了变化，就会立即存储起来，除非此时有另一个请求对其进行了变化，否则数据一定是可靠的。
	e.实时性：当某个请求被成功处理后，zookeeper仅仅保证在一定的时间段内，客户端最终一定能从服务端上读取到最新的数据状态，即zookeeper保证数据的最终一致性。

2、集群角色
zookeeper没有沿用传统的Master/Slave模式（主备模式），而是引入了Leader、Follower和Observer三种角色。
Leader：集群通过一个选举过程从所有的机器中选举一台机器作为Leader，Leader能为客户端提供读和写服务。Leader主要负责“事务请求的唯一调度者和处理者，保证集群事务处理的顺序性”、“集群内部各服务器的调度者”。
Follower：主要工作“参与Leader选举投票”、“处理客户端非事务请求，即读服务”、“转发事务请求给Leader服务器”、“参与事务请求Proposal的投票”
Observer：Observer是zookeeper自3.3.0版本开始引入的一个全新的服务器角色，充当一个观察者，工作原理和Follower一致，只是不参与任何形式的投票

3、数据结构
zookeeper的数据结构，和Unix文件系统非常类似，可以看做是一颗树，每个节点叫做ZNode。每一个节点可以通过路径来标识。每个节点上可存储少量数据，默认是1M，可以通过配置修改。
ZNode分为两种类型：
	a.临时节点ephemeral：当客户端和服务端断开连接后，所创建的节点会自动删除。
	b.持久节点persistent：当客户端和服务端断开连接后，所创建的节点不会删除。
ZNode还有一个Sequential的特性，如果创建的时候指定的话，该ZNode的名字后面会自动添加一个递增的SequenceNo。

4、选举机制
zookeeper默认的算法是FastLeaderElection，采用投票大于半数则胜出的逻辑。
zookeeper的选举机制是半数机制（Paxos协议）：投票数大于半数则胜出。
zookeeper配置文件没有指定master和slave，但是在zookeeper工作时，是有一个结点为leader，其他为Follower的。
集群中每台机器自选举过程中有这几种状态：
	Looking竞选状态
	Following随从状态，同步leader状态，参与投票
	Observering观察状态，同步leader状态，不参与投票
	Leading领导者状态

全新集群选举，假设目前5台服务器，每台服务器均没有数据，他们的编号从1到5，按编号依次启动，他们的选举过程如下：
	a.服务器1启动，给自己投票，然后发投票信息，由于其他机器还没有启动，所以它收不到反馈信息，服务器1的状态一直处于looking。
	b.服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大，所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是looking
	c.服务器3启动，给自己投票，同时与服务器12交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3称为leader
	d.服务器4启动，给自己投票，同时与之前的服务器交换信息，尽管服务器4的编号最大，但已经有了leader，4只能成为follower。服务器5启动逻辑同4.
	
非全新集群选举，对于正常运行的zookeeper集群，中途有机器down掉，需要重新选举，选举过程需要加入数据id、服务器id和逻辑时钟。
数据id：数据新的version就大，数据每次更新都会更新version
服务器id：对应配置文件中的myid值
逻辑时钟electionEpoch：这个值从0开始递增，每次选举对应一个值。在同一个选举中，这个值是一致的。
这样选举的标准就变成
	a.逻辑时钟小的选举结果被忽略，重新投票
	b.统一逻辑时钟后，数据id大的胜出
	c.数据id相同的情况下，服务器id大的胜出。

5、原子广播
所有的写操作请求被转发给leader，leader通过广播将更新信息告诉follower。当大部分跟随者执行了修改之后，leader就提交更新操作，客户端将得到更新成功的回应。未获得一致性的协议被设计为原子的，因此无论修改失败与否，它都分两阶段提交。
如果领导者出故障了，剩下存活的机器将会再次进行领导者选举，并在新leader被选举出来前继续执行任务。如果在不久后老的leader恢复了，那么它将以follower的身份继续运行。

6、监听器 Watch
ZNode发生变化（ZNode本身的增加、删除、修改以及子ZNode的变化）可以通过watch机制通知到客户端。要实现watch，必须实现Watcher接口，zookeeper中的所有读操作（getData，getChildren,exists）都可以设置watch选项。watch事件具有one-time tigger的特性，如果watch监视的ZNode有变化，那么就会通知该watch的客户端。
watch是一次性的，如果watch事件发生了，还想watch需要设置新的watch。因为watch的一次性，再次注册watch有网络延迟，所以不是每次ZNode的变更都能watch到。

7、CAP
C--consistency：一致性，数据的一致性
A--availability：可用性，系统具有好的响应性能
P--partition tolerance：分区容错性，分布式系统遇到任何网络分区故障时，仍然能够对外提供服务。

其中一致性可以分为：强一致性、顺序一致性、弱一致性。
强一致性（strict consistency）：也叫原子一致性，线性一致性。系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值。一个集群需要对外部提供强一致性，所以只要集群内部某一台服务器的数据发生了改变，那么就需要等待集群内其他服务器的数据同步完成后，才能正常的对外提供服务。
顺序一致性（sequential consistency）：任何一次读都能读到某个数据的最近一次写的数据，系统的所有进程的顺序一致，而且是合理的。即不需要和全局时钟下的顺序一致，错的话一起错，对的话一起对。
弱一致性：系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。但即使过了“不一致时间窗口”这段时间后，后续对该数据的读取也不一定是最新的。可以理解为数据更新后，能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。
最终一致性：是弱一致性的特殊形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值。不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是向趋同的方向变化。最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以区分为
	a.因果一致性：如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问，遵守一般的最终一致性规则。
	b.读己之所写一致性：当进程A自己更新一个数据项之后，它总是访问到更新到的值，绝不会看到旧值。
	c.会话一致性：把访问存储系统的进程放到会话的上下文中，只要会话还存在，系统就保证“读己之所写”的一致性。
	d.单调读一致性：如果进程已经看到过数据对象的某个值，那么任何后续访问都不会访问在那个值之前的值。
	e.单调写一致性：系统保证来自同一个进程的写操作顺序执行。

zookeeper保证CP。
zookeeper保证了最终一致性。当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受直接down掉不可用。也就是说，服务注册功能对可用性的要求高于一致性，但是zk会出现这样一种情况，当leader节点因为网络故障与其它节点失去联系时，剩余节点会重新进行选举，而选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。
Eureka保证AP。
Eureka优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作。而Eureka客户端在向Eureka注册时如果发现连接失败，则会自动切换其它节点，只要一台Eureka还在，就能保证注册服务可用，只不过查到的信息可能不是最新的。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：
a.Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。
b.Eureka依然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上。
c.当网络稳定时，当前实例新的注册信息会被同步到其他节点中。
