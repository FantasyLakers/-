# 数据结构和算法

## 1、时间空间复杂度
	时间复杂度：代码执行时间随着数据规模增长的变化趋势，也叫做渐进时间复杂度。
	空间复杂度：算法的存储空间与数据规模之间的增长关系，也叫渐进空间复杂度。
  
  	时间复杂度分析三个方法：
		a、只关注循环执行次数最多的一端代码  
		b、加法法则：总复杂度等于量级最大的那段代码的复杂度 
		c、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

  	时间复杂度的几种分析：最好情况时间复杂度、最坏情况时间复杂度、评价情况时间复杂度、均摊时间复杂度。

  	从性能上 O(logn) > O(n) > O(nlogn) > O(n^2)

    	O(logn)的代码示例：
		int i=1;
		while(i<=n){
			i = i * 2;
		}

## 2、线性表和非线性表
  	线性表：数组、链表、队列、栈等也是线性表结构。
  	非线性表：二叉树、堆、图等。

## 3、数组 Array
  	数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。数组查询高效，插入和删除操作低效。
  	数组为何从0开始？
		a[k]_address = base_address + k * type_size;
		如果从1开始，那我们计算数组a[k]的内存地址就会变为a[k]_address = base_address + （k-1）* type_size。多了一次减法操作。

## 4、链表 linked list
	三种常见的链表结构：单链表、双向链表、循环链表
	数组需要连续的内存空间，而链表不需要，它通过指针将一组零散的内存块串联起来使用。我们把内存块称为链表的结点，为了将所有的结点串联起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，我们把这个记录下个结点地址的指针叫做后继指针。
	哨兵模式：针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理，这时候我们可以使用哨兵。如果我们引入哨兵，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表，相反，没有哨兵结点的链表叫不带头链表。

## 5、淘汰策略
	FIFO：first in,first out 先进先出策略
	LFU：least frequently used 最少使用策略
	LRU：least recently used 最近最少使用策略

## 6、栈 stack
	栈是一种操作受限的线性表，只允许在一端插入和删除数据。后进者先出，先进者后出，这就是典型的栈结构。进行数据插入和删除操作的一端叫做栈顶，另一端叫做栈底。栈只支持两个基本操作，入栈push和出栈pop。
	用数组实现的栈，我们叫做顺序栈，用链表实现的栈，我们叫链式栈。

## 7、队列 queue
	队列是一种先进先出的结构，和栈一样，也是一种操作受限的线性表。
	入队enqueue（放一个数据到队列尾部）和出队dequeue（从队列头部取一个元素）。
	循环队列、阻塞队列、并发队列在底层中都起着关键性的作用。
	用数组实现的队列叫做顺序队列，用链表实现的队列叫链式队列。

## 8、递归 recursion
	f(n) = f(n-1)+f(n-2)
	递归需要满足的三个条件
	a、一个问题的解可以分解为几个子问题的解
	b、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。
	c、存在递归终止条件

## 9、排序的三个考虑因素
	原地排序：原地排序算法是指空间复杂度是O(1)的排序算法。
	稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
	比较次数和交换次数：基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。
	有序度和逆序度：有序度是数组中具有有序关系的元素对的个数。完全有序的数据叫满有序度。一组大小为n的数据，满有序度等于n(n-1)/2。
	逆序度=满有序度-有序度，我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度。

## 10、冒泡排序 bubble sort
	冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它两互换。一次冒泡会让至少一个元素移动到它应该在的位置上，重复n次，就完成了n个数据的排序工作。时间复杂度O(n^2)。

## 11、插入排序 insertion sort
	首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。插入排序的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间一直有序。重复这个过程，直到未排序区间中的元素为空，算法结束。时间复杂度O(n^2)。

## 12、选择排序 selection sort
	选择排序的算法的实现思路有点类似于插入排序，也分为已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。时间复杂度O(n^2)。

## 13、归并排序 merge sort
	我们先将数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了。归并排序用的是分治思想，将一个大的问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。时间复杂度O(nlogn)。归并排序是非原地算法。
	merge_sort(p...n)=merge(merge_sort(p...r),merge_sort(r+1,n))
	merge_sort(p...r)表示，给下标从p到r之间的数组排序。
	merge表示将已经有序的数组合并成一个有序的数组。

## 14、快速排序 quick sort
	快速排序用的也是分治思想。如果要排序数组中下标从p到n之间的数据，我们选择区间中的任意一个数据最为分区点（pivot），将小于分区点的放到左边，将大于分区点的放到右边。时间复杂度O(nlogn)。
	快速排序如何选分区点
		a.三数取中法：从区间的首、尾、中间分别取出一个数，然后比较，取这三个数的中间值作为分区点。
		b.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。

## 15、线性排序 linear sort
	因为这些算法时间复杂度是线性的，所以我们把这类排序算法叫线性排序。这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。时间复杂度为O(n)。
	桶排序bucket sort：将要排序的数据分到几个有序的桶里，每个桶里的数据进行排序，桶内排完序之后，再把每个桶里的数据顺序依次取出。桶排序对要排序的要求非常苛刻。首先，要排序的数据需要很容易分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排完序之后，桶与桶之间的数据不需要再进行排序。其次，数据在各个桶之间的分布是比较均匀的。桶排序比较适合用在外部排序中，外部排序是指数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。
	
	计数排序counting sort：计数排序是桶排序的一种特殊情况。当要排序的n个数据，所处的范围并不大时，比如最大值是k，我们就可以将这些数据划分为k个桶。每个桶内的数据都是相同的，省掉了桶内排序的时间。为什么叫计数排序呢？计数排序只能用在数据范围不大的场景中，而且只能给非负整数排序。
	
	基数排序radix sort：要求排序的数据可以分割出独立的位来比较，而且位之间有递进的关系，如果a的高位比b的高位大，那剩下的低位就不用比了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法去排序，否则，基数排序的时间复杂度就无法做到O(n)。

## 16、二分查找 binary search
	二分查找算法也叫作拆办查找算法。二分查找针对的是一个有序的数据集合，时间复杂度为O(logn);

## 17、跳表 skip list
	二分查找法要求数据是有序数组，那如果是有序链表该怎么办？这时候我们可以用跳表。
	对链表建立索引，如果我们要查找某个数据，我们可以先在索引层遍历。链表加多级索引的结构，就是跳表。

## 18、散列表 hash table
	散列表也叫哈希表，散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展。
	通过散列函数得到的散列值（哈希值），将数据放到数组中的指定位置。
	如何解决散列冲突？
		a.开放寻址法（open addressing）：如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。探测方法有线性探测方法、二次探测法、双重散列（第一次hash算法后，如果有值，再进行第二个不同的hash算法求得值）。当数据量小时，可以使用开放寻址法。
		b.链表法（chaining）：数组中的每个元素都是链表。所有散列值相同的元素都放到对应的链表中。

## 19、哈希算法 hash algorithm
	哈希算法的应用场景：负载均衡、安全加密、数据校验、数据分片、分布式存储。
	哈希算法的要求：
		a.从哈希值不能反向推导出原始数据
		b.对输入数据敏感，哪怕只修改一个Bit，最后得到的哈希值也大不相同
		c.散列冲突的概率要很小
		d.执行效率要高
		
	常见的哈希算法：MD5和SHA
	
	在分布式系统中，如果我们用哈希算法，当一台机器出现故障，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这时候我们就需要一致性哈希算法。假设我们有k个机器，数据的哈希值的范围是[0，max]。我们将整个范围划分成m个小区间，m远大于k，每个机器负责m/k个小区间。当有机器新加入的时候，我们就将某几个小区间中的数据从原来的机器中搬移到新机器中。这样就不用全部重新哈希、搬移数据了。

## 20、二叉树 binary tree
	没有父节点的节点叫做根节点，我们把没有子节点的节点叫做叶子节点或者叶节点，相同父节点的节点叫做兄弟节点。
	节点的高度：节点到叶子节点的最长路径。
	树的高度：根节点的高度
	节点的深度：根节点到这个节点所经历的边的个数
	节点的层数：节点的深度+1
	深度和高度从0开始，层从1开始。
	满二叉树：叶子节点都在最底层，除了叶子节点之外，每个节点都有左右两个子节点。
	完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大。

## 21、二叉树的遍历
	前序遍历：对于树中的任意一个节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
	中序遍历：对于树中的任意一个节点来说，先打印它的左子树，然后打印它本身，最后打印它的右子树。
	后序遍历：对于树中的任意一个节点来说，先打印它的左子树，然后再打印它的右子树，最后打印节点本身。

## 22、二叉查找树 binary search tree
	二叉查找树要求，在树的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都要大于这个节点的值。
	插入：如果要插入的数据比节点的数据大，而且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。
	删除：
		第一种情况，如果要删除的结点没有子节点，只需要将父节点中指向要删除的节点的指针置为null
		第二种情况，如果要删除的结点只有一个子节点，我们就需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点即可。
		第三种情况：如果要删除的节点有两个子节点，我们需要找到这个节点右子树中的最小节点，把他替换到要删除的节点上。然后再删除掉这个最小节点。
	中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度为O（n），非常高效。

## 23、平衡二叉查找树
	极端情况下，二叉树会退化为链表，为了解决这个问题，我们需要平衡二叉查找树。
	平衡二叉树中的任意节点的左右子树的高度相差不能大于1。最先被发明的平衡二叉查找树是AVL树，其它还有伸展树(Splay Tree)、树堆(Treap)、红黑树等等。

## 23、红黑树 red black tree
	红黑树需满足如下几个要求
		a.根节点是黑色的
		b.每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据
		c.任何相邻的节点都不能同时为红色
		d.每个节点，从该节点到其可达叶子节点的所有路径，都包含相同数目的黑色节点。

## 24、堆 heap
	堆是一种特殊的树。堆是一个完全二叉树，堆中的每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。
	对每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。
	对每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。
	堆中插入或者删除元素时，为了满足堆的特性，我们需要对堆中的元素进行调整，这个过程我们叫做“堆化”。
	堆化的方法有两种，一种是从下往上，一种是从上往下。
	从下往上的适合用来插入操作，从上往下的适合用来删除操作。（堆中的删除一般都是删除堆顶的元素）
	插入操作，将新元素放到最后，与其父节点比较，如果不满足，则交换其与父节点的位置。
	删除操作，将最后一个元素放到堆顶，然后利用同样的父子节点对比方法，对于不满足父子节点的大小关系的，互换两个节点。

## 25、堆排序
	堆排序的时间复杂度是O(nlogn)。
	堆排序可以分为两个步骤，建堆和排序。
	建堆可以从前往后（从下往上，相当于插入操作），也可以从后往前（从上到下，先从第一个非叶子节点开始比较）。
	建堆结束之后，数组中的数据已经按照大顶堆的特性来组织的，数组中的第一个元素就是顶堆，也就是最大元素。我们把它和最后一个元素交换，那最大元素就放到了下标为n的位置。再重复这个过程，直到最后堆中只剩下下标为1的一个元素，排序就完成了。
	为什么快速排序比堆排序性能好？
	 a.堆排序数据访问方式没有快速排序友好。对于快速排序，数据是顺序访问的。而对于堆排序，数据是跳着访问的。
	 b.对于同样的数据，在排序过程中，堆排序的数据交换次数要多于快速排序。

## 26、堆的应用
	a.优先级队列：优先级队列数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。堆顶元素就是优先级最高的元素。
	b.利用堆求TOP K：我们可以维护一个大小为K的堆，每次查询都查询这个堆。
	c.利用堆求中位数：我们可以维护一个大顶堆和一个小顶堆，大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。

## 27、图 Graph
	图中的元素我们叫做顶点（vertex），一个顶点到另一个顶点建立的连接关系加做边（edge），跟顶点相连接的边的条数叫做度（degree）。
有向图：我们把边有方向的图叫做有向图。在有向图中，我们把度分为入度（in-degree）和出度（out-degree），顶点的入度表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其它顶点。
无向图：反之则为无向图
带权图：weighted graph，在带权图中，每条边都有一个权重（weight）。
稀疏图：sparse graph，顶点很多，但是每个顶点的边不多。

## 28、图在内存中的存储
	a.邻接矩阵（adjacency matrix）：邻接矩阵的底层是一个二维数组。对于无向图，如果顶点i和j之间有边，就将A[i][j]和A[j][i]标记为1，对于有向图，则将A[i][j]标记为1，对于带权图，则将A[i][j]标记为权重。邻接矩阵虽然简单直接，但是比较浪费存储空间。
	b.邻接表（adjacency list）：类似于散列表，每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。邻接表比较节约空间，但是比较耗时间。我们也可以将邻接表中的链表改为平衡二叉查找树、跳表、散列表等数据结构来提升查询时间。

## 29、广度优先算法BFS和深度优先算法DFS
	BFS：breadth-first-search，是一种地毯式层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。
	DFS：depth-first-search，最直观的例子就是“走迷宫”，假设你站在迷宫的某个岔路口，然后想找到出口，你随意选择一个岔路口来走，走着走着走不通时，就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。
广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其它高级搜索算法，比如A*、IDA*等，要简单粗暴，也被叫做暴力搜索算法，所以，这两种搜索算法仅适用于状态空间不大，也就是图不大的搜索。广度优先搜索就是地毯式层层推进，从其实顶点开始，依次往外遍历。广度优先搜索算法需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是O(E)，空间复杂度是O(V)，E表示边的个数，V表示顶点的个数。

## 30、
