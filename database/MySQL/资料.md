# MySQL基础知识

## 1、当前读
更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。  
除了update语句，select语句如果加锁，也是当前读。  
update t set t.count = t.count+1 where id=1  
select k from t where id=1 lock in share mode; 读锁（S锁，共享锁）  
select k from t for update; 写锁（X锁，排他锁）

## 2、MySQL基本架构
分为客户端，server层，存储引擎。  
其中server层包括连接器（管理连接，权限验证）、分析器（语法词法分析）、优化器（执行计划生成，索引选择）、执行器（表的操作权限验证，操作引擎，返回结果）和查询缓存。所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。MySQL8.0版本删除了查询缓存的功能。  
而存储引擎负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。InnoDB从5.5.5版本开始成为MySQL的默认存储引擎。

## 3、redo log重做日志和binlog归档日志
如果每次更新操作都要写进磁盘，就要先找到磁盘上对应的那条记录，然后再更新，整个过程IO成本，查找成本都很高。为了解决这个问题，MySQL使用了redo log。当有一条记录需要更新时，InnoDB引擎会先把记录写到redo log中，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作更新到磁盘里面。redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小为1GB，从头开始写，写到末尾就又回到开头循环写。有了redo log，InnoDB就可以保证即使数据库异常重启，之前提交的记录都不会丢失，这个能力叫做crash-safe。redo log是InnoDB引擎特有的日志，而server层也有自己的日志，叫做binlog。
### redo log跟binlog有以下三个不同点
- 1、redo log是InnoDB引擎特有的，binlog是server层实现的。
- 2、redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的C字段加1”。
- 3、redo log是循环写的，空间固定会用完；binlog是可以追加写入的。
### 执行一条update语句时的流程 假如有张表有ID字段，更新ID=2这一行的C字段
- 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要从磁盘读入内存，然后再返回。
- 执行器拿到引擎给的行数据，把C的值加上1，再调用引擎接口写入这一行数据。
- 引擎将这行数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
- 执行器生成这个操作的binlog，并把binlog写入磁盘。
- 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成commit提交状态。

## 4、索引的常见模型
- 有序数组：数组查询速度很快，但是，在需要更新数据时成本太高。有序数组只适用于静态存数。
- 哈希表：将值放到数组中，用一个哈希函数将key换算成一个确定的位置，然后把value放在数组的固定位置上。哈希表这种结构适用于只有等值查询的场景。
- B+树：每一个索引在InnoDB里面对应一个B+树。
在MySQL中，索引是在存储引擎层实现的，不同引擎的索引的工作方式并不一样。在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。索引分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在InnoDB中，主键索引也叫聚簇索引（clustered index）。非主键索引的叶子节点内容是主键的值，非主键索引也被成为二级索引（secondary index）。主键索引的叶子节点存的是整行数据。非主键索引的叶子节点内容是主键的值。  
### 如果创建表时没有显示的定义主键，则InnoDB会按如下方式选择或创建主键：
- 首先判断表中有是否非空的唯一索引，如果有，则该列为主键。
- 如果不符合上述条件，InnoDB自动创建一个rowid作为主键。  
### 基于主键索引和普通索引的查询有什么区别？
- 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID索引的B+树。
- 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID=500，再到ID索引树搜索一次，这个过程称为回表。  
### 如果你有一张证件表，证件是否可以当主键？ 
- 答：由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20字节，而如果用自增主键，则只需要4个字节，如果是长整形，则是8个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间就越小。那有什么场景适合使用业务字段做主键呢？ 要求：只有一个索引，该索引必须是唯一索引。

## 5、锁
MySQL的锁大致可分成全局锁、表级锁和行锁三类。  
- 全局锁：对整个数据库实例加锁。命令 Flush tables with read lock。当你需要让整个库处于只读状态时，可以使用整个命令。全局锁的典型使用场景是做全库逻辑备份。也可以使用官方自带的逻辑备份工具mysqldump。当mysqldump使用参数-single-transaction时，导数据之前就会启动一个事务，生成一个一致性视图，而由于MVCC的支持，这个过程中数据是可以正常更新的。single-transaction方法只适用于所有的表使用事务引擎的库，即不能有MyISAM的引擎表。  
- 表级锁：表级锁分两种，一个是表锁，一个是元数据锁。表锁的语法是lock tables ... read/write。可以用unlock tables主动释放锁。另一类表级的锁是元数据锁（MDL，metadata lock）。MDL锁不需要显示使用，在访问一个表的时候回自动加上。MDL的作用是，保证读写的正确性。当对一个表做增删改查操作时，加MDL读锁；当对一个表做结构变更时，加MDL写锁。  
读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。  
给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。如何安全的给表加字段避免数据库线程爆满？MDL锁在事务提交时才会释放，为了避免MDL锁导致的等待，首先我们要解决长事务；或者在alter table语句里面设置等待时间，如果在等待的时间内拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。
- 行锁：行锁是在引擎层由各个引擎自己实现的。并不是所有的引擎都支持行锁，比如MyISAM就不支持行锁。不支持行锁则只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行。  在InnoDB中，行锁是在需要的时候才加上的，但并不是不需要了就立即释放，而是在事务结束时才释放。这个就是两阶段锁协议。如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

## 6、死锁和死锁检测
当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这些线程进入无限等待的状态，称为死锁。  
### 当出现死锁后，有两种策略。
- 1、直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置，默认值是50秒。
- 2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务能够得以继续执行。将innodb_deadlock_delete设置为on，表示开启。  
### 怎么避免死锁检测的带来的性能问题？
- 1、关闭死锁检测，风险大 
- 2、控制并发度。如果在客户端做，客户端数量多时，效果不理想。在数据库服务端做，可以考虑在中间件实现。如果可以修改MySQL源码，也可以坐在MySQL里面。基本思路是对于相同行的更新，在进入引擎前排队。
- 3、从业务设计上优化，比如影院账户，可以考虑放在多条记录上，影院的账户总额等于这10条记录的总和。这样每次给影院账户加金额时，随机选一条记录来加。

## 7、事务的隔离机制的实现
在可重复读隔离级别下，启动事务有两种方式：begin/start transaction、start transaction with consistent snapshot。  
第一种启动方式，在执行到第一个操作InnoDB表的语句，事务才真正启动。  
第二种启动方式，会立刻启动一个事务。  
在可重复读隔离级别下，InnoDB里面每个事务都有一个唯一的事务id，叫做transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按照顺序严格递增的。而每行的数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把这个transaction id赋值给这个数据版本的事务id，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本，每个版本都有自己的row trx_id。InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在活跃的所有事务id。活跃指的是，启动了但还没提交。数组里面事务id的最小值记为低水位，当前系统里面已经创建过的事务id的最大值加1记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图。而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。
- 版本未提交，不可见
- 版本已提交，但是是在视图创建后提交的，不可见
- 版本已提交，而且是在视图创建前提交的，可见。  
### 读已提交和可重复读的区别：
- 在可重复读隔离级别下，只需要在事务开启时创建一致性视图，之后事务里的其他查询都共用这个一致性视图。查询只承认在事务启动前就已经提交完成的数据。
- 在读已提交隔离级别下，每一个语句都会重新算出一个新的视图。查询只承认在语句启动前就已经提交完成的数据。

## 8、主从复制
MySQL的主从复制默认是一个异步的复制过程，数据将从一个MySQL数据库（我们称之为Master）复制到另一个MySQL数据库（我们称之为Slave），在master与slave之间实现整个主从复制的过程是由三个线程参与完成的。其中两个线程（SQL线程和I/O线程）在slave端，另一个线程在master端（I/O线程）。  
要实现MySQL的主从复制，首先必须打开master端的binlog记录功能，整个实际的复制过程就是slave从master端获取binlog日志，然后再在slave上以相同顺序执行获取的binlog日志中记录的各种sql操作。  
从库IO在把信息放入到中继日志relay-log中后会触发sql线程，sql线程会把binlog中的sql语句解析出来变成sql语句放入数据库中。

三种主从复制模式
- 异步模式：这种模式下，主节点不会主动push binlog到从节点，这种会有延迟。
- 半同步模式：这种模式下主节点只需要接收到其中一台从节点的返回信息，就会commit；否则需要等待直到超时时间然后切换成异步模式再提交。
- 全同步：这种模式下需要所有从节点全部执行了commit并确认才会向客户端返回成功。

## 9、binlog格式
- statement格式：基于sql语句的模式，某些语句和函数如UUID，LOAD DATA INFILE等在复制过程中可能导致数据不一致甚至出错。
- row格式：基于行的模式，记录的是行的变化，很安全，但是binlog文件会比其他两种模式大很多，在一些大表中清除大量数据时会导致延迟变大。
- mixed格式：混合模式，根据语句来选用是statement模式还是row模式。

## 10、MySQL是怎么保证数据不丢的？
只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。

- binlog的写入机制：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了 binlog cache 的保存问题。系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态如图 1 所示。  ![images](https://github.com/FantasyLakers/my-lessons/blob/master/database/MySQL/binlog%E5%86%99%E5%85%A5%E6%AD%A5%E9%AA%A4.png?raw=true)   
可以看到，每个线程有自己 binlog cache，但是共用同一份 binlog 文件。图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。  
write 和 fsync 的时机，是由参数 sync_binlog 控制的：
  - sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；
  - sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；
  - sync_binlog=N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。  
    
  因此，在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。  
  
- redo log的写入机制：事务在执行过程中，生成的 redo log 是要先写到 redo log buffer 的。redo log buffer 里面的内容。 **是不是每次生成后都要直接持久化到磁盘呢？** 答案是，不需要。如果事务执行期间 MySQL 发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。 **那么，另外一个问题是，事务还没提交的时候，redo log buffer 中的部分日志有没有可能被持久化到磁盘呢？** 答案是，确实会有。    

这个问题，要从 redo log 可能存在的三种状态说起，这三种状态分别是：
  - 存在 redo log buffer 中，物理上是在 MySQL 进程内存中
  - 写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面
  - 持久化到磁盘  
  
日志写到 redo log buffer 是很快的，wirte 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：
  - 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;
  - 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；
  - 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。  
  
InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。注意，事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。
    - 一种是，redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。
    - 另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。


