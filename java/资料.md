# Java知识点

## 1、元注解
- @Rentention：保留策略  
	- @Rentention(RententionPolicy.SOURCE)：编译器要丢弃的注释  
	- @Rentention(RententionPolicy.CLASS)：编译器把注释记录在类文件中，但在运行时不需要保留注释  
	- @Rentention(RententionPolicy.RUNTIME)：编译器把注释记录在类文件中，在运行时刻通过反射来获取  
- @Target：注解的目标对象 
	- ANNOTATION_TYPE：标注注释类型    
	- METHOD：标注方法  
	- CONSTRUCTOR：标注构造方法  	      
	- PACKAGE：标注包  
	- FIELD：标注字段  	      
	- PARAMETER：标注参数  
	- LOCAL_VARIABLE：标注局部变量  
	- TYPE：标注类、接口（包括注释类型）或枚举声明
- @DOCUMENTED
	- 如果类型声明是用Documented来注释的，则其注释将成为注释元素的公共API的一部分。
- @Inherited
	- 允许子类继承父类中的注解

## 2、锁的分类与使用
[锁的分类与使用](https://www.cnblogs.com/hustzzl/p/9343797.html)

## 3、synchronized
synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：
- 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
- 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
- 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；

## 4、ReentrantLock
ReentrantLock和synchronized都是可重入锁。
```java
	class X {
   		private final ReentrantLock lock = new ReentrantLock();

   		public void m() { 
     			lock.lock();  // block until condition holds
     			try {
       				// ... method body
     			} finally {
      		 		lock.unlock()
     			}
   		}	
	 }
```

### ReentrantLock和synchronized的比较
- ReentrantLock功能性方面更全面，比如时间锁等候，可中断锁等候，锁投票等，因此更有扩展性。在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。
- ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错。
- ReentrantLock 的性能比synchronized会好点。
- ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。
- Lock的某些方法可以决定多长时间内尝试获取锁，如果获取不到就抛异常，这样就可以一定程度上减轻死锁的可能性。
如果锁被另一个线程占据了，synchronized只会一直等待，很容易错序死锁 
- synchronized的话，锁的范围是整个方法或synchronized块部分；而Lock因为是方法调用，可以跨方法，灵活性更大 

## 5、线程池 
线程池的思想是：在系统中开辟一块区域，其中存放一些待命的线程，这个区域被称为线程池。如果有需要执行的任务，则从线程池中借一个待命的线程来执行指定的任务，到任务结束可以再将所借线程归还。这样就避免了大量重复创建线程对象，浪费CPU，内存资源。
### 线程池的核心参数
- poolSize：线程池中当前线程的数量。
- corePoolSize：池中所保存的线程数，包括空闲线程
- maximumPoolSize：线程池最大线程数量。  
- keepAliveTime：线程数量超过corePoolSize时，多于的空闲线程的存活时间（超过这段时间，该空闲线程会被销毁）。  
- unit：keepAliveTime的单位，参见枚举类TimeUnit  
- workQueue：一个阻塞队列，用来存储等待执行的任务。这队列用来保持那些execute()方法提交的还没有执行的任务。常用的队列有- SynchronousQueue,LinkedBlockingQueue,ArrayBlockingQueue。 
- threadFactory：执行程序创建新线程使用的工厂  
- handler：由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。当线程的数量已经到了边界值，并且workQueue中任务也达到最大值，此时需要使用处理器处理多余的任务。该参数有四个值，分别是CallerRunsPolicy，AbortPolicy，DiscardPolicy，DiscardOldestPolicy。这四个处理器是线程池的内部类，都实现了RejectedExecutionHandler接口。
	- CallerRunsPolicy:在调用execut方法的调用线程中直接执行线程池拒绝的任务；
	- AbortPolicy：以抛出一个RejectedExecutionException的方式处理拒绝执行的任务；
	- DiscardPolicy：以直接忽略的方式处理拒绝执行的任务；
	- DiscardOldestPolicy：忽略掉最老的没有处理的拒绝任务，然后继续尝试执行execute方法，直到线程池关闭。
	
### 那么poolSize、corePoolSize、maximumPoolSize三者的关系是如何的呢？当新提交一个任务时：
- 如果poolSize<corePoolSize，新增加一个线程处理新的任务。
- 如果poolSize=corePoolSize，新任务会被放入阻塞队列等待。
- 如果阻塞队列的容量达到上限，且这时poolSize<maximumPoolSize，新增线程来处理任务。
- 如果阻塞队列满了，且poolSize=maximumPoolSize，那么线程池已经达到极限，会根据饱和策略RejectedExecutionHandler执行新的任务

**如果观察jdk提供的各种线程池的源码实现可以发现，除了jdk8新增的线程池newWorkStealingPool以外，都是基于对ThreadPoolExecutor的封装实现**
```java	
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

Executors工厂方法来创建线程池：
- Executors.newCachedThreadPool：无界线程池，可以进行自动线程回收。适用于执行大量耗时小的任务   
```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

- Executors.newFixedThreadPool：线程数量固定的线程池，即只有核心线程，可以更快的响应外界请求
```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

- Executors.newSingleThreadPool：单个后台线程
```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```

- Executors.newScheduledThreadPool：核心线程数量是固定的，非核心线程数量是不固定的，当非核心线程闲置时他会被立即回收。主
要用于执行定时任务和具有固定时期的重复任务。
```java
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
    
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
    
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

## 6、四种引用--可以让程序员通过代码的方式决定某些对象的生命周期；有利于JVM进行垃圾回收。
- **强引用**：指创建一个对象并把这个对象赋给一个引用变量。
	```java
	Object obj = new Object(); // 只要引用存在，垃圾回收器永远不会回收，只有当obj被这个引用被释放掉之后，对象才会被释放掉
	```

- **软引用SoftReference**：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收他。如果内存空间不足，就会被回收。软引用可以
和引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收了，java虚拟机就会把这个软引用加入到与之关联的引用队列中。
	```java
	Object obj = new Object();
	SoftReference<Object> sf = new SoftReference<Object>(obj);
	obj = null;
	sf.get(); // 有时会返回null
	```
这个时候sf是对obj的软引用，通过sf.get()方法可以去到这个对象，当然，当这个对象被标记为需要回收的对象时，会返回null。软应用主要用来实现类似缓存的功能，在内存足够的时候，直接通过软引用取值，无需从繁忙的真实来源取值，提升性能。当内存不足时，自动删除这些缓存数据，再从真实来源查询这些数据。

- **弱引用WeakReference**：弱引用也是用来描述非必须对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱
引用可以和引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收了，java虚拟机就会把这个弱引用加入到与之关联的引用队列
中。
	```java		
	Object obj = new Object();
	WeakReference<Object> wf = new WeakReference<Object>(obj);
	obj = null;
	wf.get(); // 有时会返回null
	wf.isEnQueued(); // 返回是否被垃圾回收器标记为即将回收的垃圾。
	```

- **虚引用PhantomReference**：虚引用不影响对象的生命周期，如果一个对象和虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用对象的内存被回收之前采取必要的行动。
	```java
	Object obj = new Object();
	PhantomReference<Object> pf = new PhantomReference<Object>(obj);
	obj = null;
	pf.get(); // 永远返回null
	pf.isEnQueued();
	```

补充说明：在任何时候我们都可以调用ReferenceQueue的Poll()方法来检查是否有他所关心的非强可及对象被回收。如果队列为空，则返回一个null，否则返回队列中前面的一个Reference对象。

## 7、位运算符
- 按位与 & ：同时为1则为1，否则为0
- 按位或 |：只要一个为1，则为1
- 异或  ^ ：两个相应位值不同，则为1，否则为0
- 右移运算符：>>，右移相当于除以2的N次方，舍弃余数，符号位也会移动，左补0或1，看是正数还是负数
- 左移运算符：<<，左移相当于乘以2的N次方
- 无符号右移运算符：>>>

## 8、虚拟机参数
-Xms：虚拟机堆区内存初始内存大小，通常为操作系统可用内存的1/64大小即可。-Xms1024m    
-Xmx：虚拟机堆区内存最大内存大小，通常为操作系统可用内存的1/4大小。-Xmx2048m    
-XX:MinHeapFreeRatio：设置堆空间的最小空间比例。当堆空间的空闲内存小于这个数值时，jvm便会扩展堆空间  
-XX:MaxHeapFreeRatio：设置堆空间的最大空间比例。当堆空间的空闲内存大于这个数值时，jvm便会缩小堆空间  
-XX:PermSize：表示非堆区初始内存分配大小，即永久区。-XX:PermSize=256m    
-XX:MaxPermSize：表示对非堆区分配的内存的最大上限。-XX:MaxPermSize=512m    
-Xss：设置线程栈的大小  
-XX:NewSize=n 设置年轻代大小  
-XX:NewRatio=n 设置年轻代和年老代的比例。假如值为3，表示年轻代和年老代比值为1:3  
-XX:+PrintGCDetails：打印gc日志  
-XX:+PrintHeapAtGC：在gc前后，都输出详细的堆信息         

## 9、垃圾收集算法
### 如何判断对象是否还存活
- 引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减一。但是对象之间相互循环引用会导致该算法出现问题。
- 可达性分析算法：这个算法的基本思路是通过一系列的称之为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。在java中，可作为GC Roots的对象包括虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常亮引用的对象、本地方法栈中JNI（即Native方法）引用的对象。
### 收集算法
- 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。不足之处在于 1、效率问题，标记和清除的两个过程效率都不太高 2、空间问题  标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
- 复制算法：将可用内存按容量划分为等量的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法现在大多用来清理新生代。由于新生代朝生夕死，所以将内存分为一个较大的Eden区域和两块较小的Survivor区域，当回收时，将Eden和Survivor上存活的对象复制到另一块Survivor中，然后清理Eden和Survivor，当Survivor空间不足时，需要将某些新生代通过分配担保机制进入老年代。
- 标记-整理算法：类似于标记清除算法，标记完成后将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
- 分代收集算法：将对象分为新生代和老年代，在新生代中，每次垃圾收集时都有大批对象死去，就选用复制算法。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记清理或标记整理算法进行回收。

## 10、java内存区域
- 程序计数器：是一块较小的内存空间，它可以看成是当前线程所执行的字节码的行号指示器。每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。该内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
- java虚拟机栈（Stack）：和程序计数器一样是线程私有的，它的生命周期和线程相同。每个方法在执行的同时会创建一个栈帧用语存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型(int/short/float/long/double/boolean/char/byte)、对象引用。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverfolwError异常，如果虚拟机允许动态扩展，但无法申请到足够的内存，将抛出OutOfMemeroyError异常。
- 本地方法栈：和虚拟机栈类似，本地方法栈用于执行Native方法。
- java堆(Heap)：java堆是被所有线程共享的内存区域，几乎所有的对象实例和数组都要在堆上分配
- 方法区(永久代)：和java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 运行时常量池：是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

## 11、Java设计原则
- 单一原则一个类只负责一项职责。
- 里氏替换原则
	* 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
	* 子类中可以增加自己特有的方法
	* 当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松
	* 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格
- 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。例如有一个方法tellStory，它的参数为Book实体类，而不是接口或抽象类，这是不应该的。
	```java
	public void tellStory(Book book){
		// tellStory
	}
	```
- 接口隔离原则：客户端不应该依赖他不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上
- 迪米特法则（最少知道原则）：一个类要尽量的封装自己，一个类只与自己的朋友类打交道（朋友类：朋友类是成员变量或者方法参数，非朋友类一般都是局部变量）
- 开闭原则：对扩展开放，对修改闭合

## 12、java.util包和java.util.concurrent包下的关键类和接口
### Queue：队列是一个先进先出的（FIFO）的数据结构。常用的并发队列有阻塞队列和非阻塞队列，前者使用锁实现，后者则使用CAS非阻塞算法实现。
- 非阻塞队列：
	- LinkedList：一个由链表结构组成的双向队列。
	- PriorityQueue：一个由数组结构组成的基于优先级的无界优先级队列。
	- ConcurrentLinkedQueue：一个采用链表实现的无界非阻塞**线程安全**队列。
- 阻塞队列（继承BlockingQueue）
	- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。
	- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。
	- PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。默认情况下队列中的元素采取自然顺序排序，也可以通过比较器comparator来指定元素的排序规则。
	- DelayQueue：一个使用优先级队列PriorityBlockingQueue实现的无界阻塞队列，是一个支持延时获取元素的队列。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取元素，只有在延迟期满时才能从队列中提取元素。
	- SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。
	- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。**transfer方法**：如果当前由消费者正在等待接收元素，transfer可以把生产者传入的元素立刻transfer给消费者。如果没有消费者正在等待，transfer方法会将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。**tryTransfer方法**：是用来试探生产者传入的元素是否能直接传给消费者，如果没有消费者在等待，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接受，方法立即返回，而transfer方法是必须等到消费者消费了才返回。
	- LinkedBlockingDeque：一个由链表结构组成的**双向阻塞队列**。
### List
- ArrayList：底层是动态数组。
- LinkedList：底层是双向链表。
- Vector：线程安全的动态数组。
### Map
- HashMap：底层是散列表。
- ConcurrentHashMap：线程安全的。
- HashTable：线程安全的。
- TreeMap：实现了SortedMap接口，能够把它保存的记录根据键值排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。
- LinkedHashMap：是HashMap的子类，LinkedHashMap中的遍历可分为插入顺序和访问顺序两种，底层维护了一个双向链表用来保存元素的顺序。构造方法中的accessOrder默认为为false，表示LinkedHashMap中存储的元素是按照调用put方法插入的顺序进行排序的，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。
- 一般情况下，我们用的最多的是HashMap。HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map中插入、删除和定位元素，HashMap 是最好的选择。TreeMap取出来的是排序后的键值对，如果要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。LinkedHashMap是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现。它还可以按读取顺序来排列，像连接池中可以应用。
### Set
- HashSet：底层是HashMap，不能保证元素的顺序。允许null值。HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hash值作为标识的。
- TreeSet：底层是TreeMap，可以保证元素是由顺序的。不允许null值。TreeSet的底层实现是采用红-黑树的数据结构，采用这种结构可以从Set中获取有序的序列，但是前提条件是：元素必须实现Comparable接口。

## 13、ThreadLocal类
ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有自己独立的变量。ThreadLocal采用了“以空间换时间”的方式：访问并行化，对象独享化。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。  

```java
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }

    private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }

    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }

    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    
    
```
ThreadLocal的实现原理：每个ThreadLocal的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。

```java
	static class ThreadLocalMap {

        	static class Entry extends WeakReference<ThreadLocal<?>> {
           		 /** The value associated with this ThreadLocal. */
            		Object value;

            		Entry(ThreadLocal<?> k, Object v) {
               	 		super(k);
               	 		value = v;
            		}
        	}
		
		ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
            		table = new Entry[INITIAL_CAPACITY];
            		int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
            		table[i] = new Entry(firstKey, firstValue);
            		size = 1;
            		setThreshold(INITIAL_CAPACITY);
        	}
	}
```

### ThreadLocal为什么会内存泄漏？
ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用用来引用它，那么系统GC的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref->Thread->ThreadLocalMap->Entry-value永远无法回收，造成内存泄漏。其实，ThreadLocalMap的设计中已经考虑到了这种情况，也加上了一些防护措施：在ThreadLocal的get（），set（），remove（）的时候都会清除线程ThreadLocalMap里所有key为null的value。

从表面上看内存泄漏的根源在于使用了弱引用。为什么使用弱引用而不是强引用？下面我们分两种情况讨论：
- key使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。
- key使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。
比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。

## 14、volatile关键字
[volatile关键字](https://www.cnblogs.com/dolphin0520/p/3920373.html)

## 15、IO

## 16、NIO

## 17、零拷贝 zero copy
Java的NIO为了支持零拷贝，提供了一些类：
- DirectByteBuffer：DirectByteBuffer直接在堆外分配内存，底层是直接通过JNI调用操作系统的NIO系统调用，所以性能会比较高。
- FileChannel：是Java NIO提供的用于复制文件的类，可以把文件复制到磁盘或者网络等。transferTo方法直接将当前通道内容传输到另一个通道，也就是说这种方式不会有内核缓冲区到用户缓冲区的读写问题。底层是sendfile系统调用。transferFrom方法同理。

## 18、反射

## 19、rmi

## 20、java.security

## 21、类加载机制

## 22、线程状态
- NEW
- BLOCKED
- RUNNABLE
- WAITING
- TIMED_WAITING
- TERMINATED

## 23、动态代理

## 24、java8中ConcurrentHashMap的变化
[Java8之前ConcurrentHashMap的原理分析](https://blog.csdn.net/jiahao1186/article/details/83689241)
[Java8中的ConcurrentHashMap的原理分析](https://blog.csdn.net/u010723709/article/details/48007881)

## 25、java8中HashMap的变化
[Java8和Java7中HashMap的变化](https://www.cnblogs.com/jajian/p/10385063.html)

## 26、什么是AQS
[AQS的全称是AbstractQueuedSynchronizer：抽象队列同步器。](https://www.cnblogs.com/waterystone/p/4920797.html)
