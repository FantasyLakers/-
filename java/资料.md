# Java知识点

## 1、元注解
- @Rentention：保留策略  
	- @Rentention(RententionPolicy.SOURCE)：编译器要丢弃的注释  
	- @Rentention(RententionPolicy.CLASS)：编译器把注释记录在类文件中，但在运行时不需要保留注释  
	- @Rentention(RententionPolicy.RUNTIME)：编译器把注释记录在类文件中，在运行时刻通过反射来获取  
- @Target：注解的目标对象 
	- ANNOTATION_TYPE：标注注释类型    
	- METHOD：标注方法  
	- CONSTRUCTOR：标注构造方法  	      
	- PACKAGE：标注包  
	- FIELD：标注字段  	      
	- PARAMETER：标注参数  
	- LOCAL_VARIABLE：标注局部变量  
	- TYPE：标注类、接口（包括注释类型）或枚举声明
- @DOCUMENTED
	- 如果类型声明是用Documented来注释的，则其注释将成为注释元素的公共API的一部分。
- @Inherited
	- 允许子类继承父类中的注解

## 2、锁的分类与使用
[锁的分类与使用](https://www.cnblogs.com/hustzzl/p/9343797.html)

## 3、synchronized
synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：
- 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
- 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
- 修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；

```java
public class SynchronizeTest {

	/**
	* 对当前对象加锁
	* synchronized修饰方法块时，不同线程调用同一个对象去调用该方法块，只会有一个线程执行该段代码
	* 不同线程不同的对象能同时访问该部分代码块
	*/
	public void test1() {
		synchronized(this){
			for (int num = 0; num < 50; num++) {
				System.out.println("test1 "+Thread.currentThread().getName());
			}
		}
	}
	
	/**
	* synchronized(Object.class)
	* 当对Object对象上锁时，同一时间只能有一个线程访问该代码块
	*/
	public void test2() {
		synchronized(Object.class){
			for (int num = 0; num < 50; num++) {
				System.out.println("test2 "+Thread.currentThread().getName());
			}
		}
	}
	
	/**
	* synchronized(SynchronizeOnCodeBlock.class)
	* 当对SynchronizeOnCodeBlock对象上锁时，同一时间只能有一个线程访问该代码块
	*/
	public void test3() {
		synchronized (SynchronizeOnCodeBlock.class) {
			for (int num = 0; num < 50; num++) {
				System.out.println("test3 " + Thread.currentThread().getName());
			}
		}
	}
	
	/**
	 * synchronized修饰方法时，不同线程调用同一个对象去调用该方法，只会有一个线程执行该段代码
	*/
	public synchronized void test4() {
		for (int num = 0; num < 50; num++) {
			System.out.println("test1 " + Thread.currentThread().getName());
		}
	}

	/**
	* synchronized修饰静态方式时，和synchronized(SynchronizeOnMethod.class)类似，同一时间只能有一个线程访问
	*/
	public static synchronized void test5() {
		for (int num = 0; num < 50; num++) {
			System.out.println("test2 " + Thread.currentThread().getName());
		}
	}

}
```

**线程间通信**
```java
public class WaitAndNotifyTest {

	static Object obj = new Object();
	static int state = 1;
	
	public static void main(String[] args) {
		Thread t1 = new PrintOddThread();
		Thread t2 = new PrintEvenThread();
		t1.start();
		t2.start();
	}

	/**
	 * 打印奇数，每次打印五个，然后另一个线程打印偶数
	 */
	static class PrintOddThread extends Thread{
		
		@Override
		public void run() {
			synchronized (obj) {
				int num = 1;
				
				while(num <100){
					
					if(state  != 1){
						try {
							obj.wait();
						} catch (InterruptedException e1) {
							e1.printStackTrace();
						}
					}
				
					for(int i = 0;i < 5;i++){
						System.out.println(num);
						num = num + 2;
					}
					
					state =2;
					
					/**
					 * 唤醒之后从while处再次执行，到wait处停下，CPU自动选择一个等待中的线程执行
					 */
					obj.notifyAll();

				}
			}
		}
	}
	
	/**
	 * 打印偶数
	 */
	static class PrintEvenThread extends Thread{

		@Override
		public void run() {
			synchronized (obj) {
				int num = 2;
				
				while(num <100){
					
					if(state  != 2){
						try {
							obj.wait();
						} catch (InterruptedException e1) {
							e1.printStackTrace();
						}
					}
				
					for(int i = 0;i < 5;i++){
						System.out.println(num);
						num = num + 2;
					}
					
					state =1;
					
					obj.notifyAll();

				}
			}
		}
	}
}

```

## 4、ReentrantLock
ReentrantLock和synchronized都是可重入锁。
```java
	class X {
   		private final ReentrantLock lock = new ReentrantLock();

   		public void m() { 
     			lock.lock();  // block until condition holds
     			try {
       				// ... method body
     			} finally {
      		 		lock.unlock()
     			}
   		}	
	 }
```

**使用ReentrantLock和Condition实现消费者和生产者模型**
```java
/**
 * 线程间通信
 */
public class LockAndConditionTest{
	
	static int state = 1;
	
	static Lock lock = new ReentrantLock();
	static Condition oddCon = lock.newCondition();
	static Condition evenCon = lock.newCondition();
	
	public static void main(String[] args) {
		
		Thread t1 = new PrintOddThread();
		Thread t2 = new PrintEvenThread();
		t1.start();
		t2.start();
	}

	/**
	 *	打印奇数，每次打印五个，然后另一个线程打印偶数
	 */
	static class PrintOddThread extends Thread{
		
		@Override
		public void run() {
			
			int num = 1;
			
			while(num <100){
				
				// 非阻塞
				lock.lock();
				
				if(state  != 1){
					try {
						// 阻塞
						oddCon.await();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			
				for(int i = 0;i < 5;i++){
					System.out.println(num);
					num = num + 2;
				}
				
				state =2;
				
				evenCon.signalAll();
				
				lock.unlock();
				
			}
		}
	}
	
	static class PrintEvenThread extends Thread{

		@Override
		public void run() {
			
			int num = 2;
			
			while(num <100){
				
				lock.lock();
				
				if(state  != 2){
					try {
						evenCon.await();
					} catch (InterruptedException e1) {
						e1.printStackTrace();
					}
				}
			
				for(int i = 0;i < 5;i++){
					System.out.println(num);
					num = num + 2;
				}
				
				state =1;
				
				oddCon.signalAll();
				
				lock.unlock();
				
			}
		}
	}
	
}

```

### ReentrantLock和synchronized的比较
- ReentrantLock功能性方面更全面，比如时间锁等候，可中断锁等候，锁投票等，因此更有扩展性。在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。
- ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错。
- ReentrantLock 的性能比synchronized会好点。
- ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。
- Lock的某些方法可以决定多长时间内尝试获取锁，如果获取不到就抛异常，这样就可以一定程度上减轻死锁的可能性。
如果锁被另一个线程占据了，synchronized只会一直等待，很容易错序死锁 
- synchronized的话，锁的范围是整个方法或synchronized块部分；而Lock因为是方法调用，可以跨方法，灵活性更大 

## 5、线程池 
线程池的思想是：在系统中开辟一块区域，其中存放一些待命的线程，这个区域被称为线程池。如果有需要执行的任务，则从线程池中借一个待命的线程来执行指定的任务，到任务结束可以再将所借线程归还。这样就避免了大量重复创建线程对象，浪费CPU，内存资源。
### 线程池的核心参数
- poolSize：线程池中当前线程的数量。
- corePoolSize：池中所保存的线程数，包括空闲线程
- maximumPoolSize：线程池最大线程数量。  
- keepAliveTime：线程数量超过corePoolSize时，多于的空闲线程的存活时间（超过这段时间，该空闲线程会被销毁）。  
- unit：keepAliveTime的单位，参见枚举类TimeUnit  
- workQueue：一个阻塞队列，用来存储等待执行的任务。这队列用来保持那些execute()方法提交的还没有执行的任务。常用的队列有- SynchronousQueue,LinkedBlockingQueue,ArrayBlockingQueue。 
- threadFactory：执行程序创建新线程使用的工厂  
- handler：由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。当线程的数量已经到了边界值，并且workQueue中任务也达到最大值，此时需要使用处理器处理多余的任务。该参数有四个值，分别是CallerRunsPolicy，AbortPolicy，DiscardPolicy，DiscardOldestPolicy。这四个处理器是线程池的内部类，都实现了RejectedExecutionHandler接口。
	- CallerRunsPolicy:在调用execut方法的调用线程中直接执行线程池拒绝的任务；
	- AbortPolicy：以抛出一个RejectedExecutionException的方式处理拒绝执行的任务；
	- DiscardPolicy：以直接忽略的方式处理拒绝执行的任务；
	- DiscardOldestPolicy：忽略掉最老的没有处理的拒绝任务，然后继续尝试执行execute方法，直到线程池关闭。
	
### 那么poolSize、corePoolSize、maximumPoolSize三者的关系是如何的呢？当新提交一个任务时：
- 如果poolSize<corePoolSize，新增加一个线程处理新的任务。
- 如果poolSize=corePoolSize，新任务会被放入阻塞队列等待。
- 如果阻塞队列的容量达到上限，且这时poolSize<maximumPoolSize，新增线程来处理任务。
- 如果阻塞队列满了，且poolSize=maximumPoolSize，那么线程池已经达到极限，会根据饱和策略RejectedExecutionHandler执行新的任务

**如果观察jdk提供的各种线程池的源码实现可以发现，除了jdk8新增的线程池newWorkStealingPool以外，都是基于对ThreadPoolExecutor的封装实现**
```java	
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

Executors工厂方法来创建线程池：
- Executors.newCachedThreadPool：无界线程池，可以进行自动线程回收。适用于执行大量耗时小的任务   
```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

- Executors.newFixedThreadPool：线程数量固定的线程池，即只有核心线程，可以更快的响应外界请求
```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

- Executors.newSingleThreadPool：单个后台线程
```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```

- Executors.newScheduledThreadPool：核心线程数量是固定的，非核心线程数量是不固定的，当非核心线程闲置时他会被立即回收。主
要用于执行定时任务和具有固定时期的重复任务。
```java
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
    
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
    
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

## 6、四种引用--可以让程序员通过代码的方式决定某些对象的生命周期；有利于JVM进行垃圾回收。
- **强引用**：指创建一个对象并把这个对象赋给一个引用变量。
	```java
	Object obj = new Object(); // 只要引用存在，垃圾回收器永远不会回收，只有当obj被这个引用被释放掉之后，对象才会被释放掉
	```

- **软引用SoftReference**：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收他。如果内存空间不足，就会被回收。软引用可以
和引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收了，java虚拟机就会把这个软引用加入到与之关联的引用队列中。
	```java
	Object obj = new Object();
	SoftReference<Object> sf = new SoftReference<Object>(obj);
	obj = null;
	sf.get(); // 有时会返回null
	```
这个时候sf是对obj的软引用，通过sf.get()方法可以去到这个对象，当然，当这个对象被标记为需要回收的对象时，会返回null。软应用主要用来实现类似缓存的功能，在内存足够的时候，直接通过软引用取值，无需从繁忙的真实来源取值，提升性能。当内存不足时，自动删除这些缓存数据，再从真实来源查询这些数据。

- **弱引用WeakReference**：弱引用也是用来描述非必须对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱
引用可以和引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收了，java虚拟机就会把这个弱引用加入到与之关联的引用队列
中。
	```java		
	Object obj = new Object();
	WeakReference<Object> wf = new WeakReference<Object>(obj);
	obj = null;
	wf.get(); // 有时会返回null
	wf.isEnQueued(); // 返回是否被垃圾回收器标记为即将回收的垃圾。
	```

- **虚引用PhantomReference**：虚引用不影响对象的生命周期，如果一个对象和虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用对象的内存被回收之前采取必要的行动。
	```java
	Object obj = new Object();
	PhantomReference<Object> pf = new PhantomReference<Object>(obj);
	obj = null;
	pf.get(); // 永远返回null
	pf.isEnQueued();
	```

补充说明：在任何时候我们都可以调用ReferenceQueue的Poll()方法来检查是否有他所关心的非强可及对象被回收。如果队列为空，则返回一个null，否则返回队列中前面的一个Reference对象。

## 7、位运算符
- 按位与 & ：同时为1则为1，否则为0
- 按位或 |：只要一个为1，则为1
- 异或  ^ ：两个相应位值不同，则为1，否则为0
- 右移运算符：>>，右移相当于除以2的N次方，舍弃余数，符号位也会移动，左补0或1，看是正数还是负数
- 左移运算符：<<，左移相当于乘以2的N次方
- 无符号右移运算符：>>>

## 8、虚拟机参数
-Xms：虚拟机堆区内存初始内存大小，通常为操作系统可用内存的1/64大小即可。-Xms1024m    
-Xmx：虚拟机堆区内存最大内存大小，通常为操作系统可用内存的1/4大小。-Xmx2048m    
-XX:MinHeapFreeRatio：设置堆空间的最小空间比例。当堆空间的空闲内存小于这个数值时，jvm便会扩展堆空间  
-XX:MaxHeapFreeRatio：设置堆空间的最大空间比例。当堆空间的空闲内存大于这个数值时，jvm便会缩小堆空间  
-XX:PermSize：表示非堆区初始内存分配大小，即永久区。-XX:PermSize=256m    
-XX:MaxPermSize：表示对非堆区分配的内存的最大上限。-XX:MaxPermSize=512m    
-Xss：设置线程栈的大小  
-XX:NewSize=n 设置年轻代大小  
-XX:NewRatio=n 设置年轻代和年老代的比例。假如值为3，表示年轻代和年老代比值为1:3  
-XX:+PrintGCDetails：打印gc日志  
-XX:+PrintHeapAtGC：在gc前后，都输出详细的堆信息         

## 9、垃圾收集算法
### 如何判断对象是否还存活
- 引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减一。但是对象之间相互循环引用会导致该算法出现问题。
- 可达性分析算法：这个算法的基本思路是通过一系列的称之为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。在java中，可作为GC Roots的对象包括虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常亮引用的对象、本地方法栈中JNI（即Native方法）引用的对象。
### 收集算法
- 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。不足之处在于 1、效率问题，标记和清除的两个过程效率都不太高 2、空间问题  标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
- 复制算法：将可用内存按容量划分为等量的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法现在大多用来清理新生代。由于新生代朝生夕死，所以将内存分为一个较大的Eden区域和两块较小的Survivor区域，当回收时，将Eden和Survivor上存活的对象复制到另一块Survivor中，然后清理Eden和Survivor，当Survivor空间不足时，需要将某些新生代通过分配担保机制进入老年代。
- 标记-整理算法：类似于标记清除算法，标记完成后将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
- 分代收集算法：将对象分为新生代和老年代，在新生代中，每次垃圾收集时都有大批对象死去，就选用复制算法。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记清理或标记整理算法进行回收。

## 10、java内存区域
- 程序计数器：是一块较小的内存空间，它可以看成是当前线程所执行的字节码的行号指示器。每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。该内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
- java虚拟机栈（Stack）：和程序计数器一样是线程私有的，它的生命周期和线程相同。每个方法在执行的同时会创建一个栈帧用语存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型(int/short/float/long/double/boolean/char/byte)、对象引用。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverfolwError异常，如果虚拟机允许动态扩展，但无法申请到足够的内存，将抛出OutOfMemeroyError异常。
- 本地方法栈：和虚拟机栈类似，本地方法栈用于执行Native方法。
- java堆(Heap)：java堆是被所有线程共享的内存区域，几乎所有的对象实例和数组都要在堆上分配
- 方法区(永久代)：和java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 运行时常量池：是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

## 11、Java设计原则
- 单一原则一个类只负责一项职责。
- 里氏替换原则
	* 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
	* 子类中可以增加自己特有的方法
	* 当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松
	* 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格
- 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。例如有一个方法tellStory，它的参数为Book实体类，而不是接口或抽象类，这是不应该的。
	```java
	public void tellStory(Book book){
		// tellStory
	}
	```
- 接口隔离原则：客户端不应该依赖他不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上
- 迪米特法则（最少知道原则）：一个类要尽量的封装自己，一个类只与自己的朋友类打交道（朋友类：朋友类是成员变量或者方法参数，非朋友类一般都是局部变量）
- 开闭原则：对扩展开放，对修改闭合

## 12、java.util包和java.util.concurrent包下的关键类和接口
### Queue：队列是一个先进先出的（FIFO）的数据结构。常用的并发队列有阻塞队列和非阻塞队列，前者使用锁实现，后者则使用CAS非阻塞算法实现。
- 非阻塞队列：
	- LinkedList：一个由链表结构组成的双向队列。
	- PriorityQueue：一个由数组结构组成的基于优先级的无界优先级队列。
	- ConcurrentLinkedQueue：一个采用链表实现的无界非阻塞**线程安全**队列。
- 阻塞队列（继承BlockingQueue）
	- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。
	- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。
	- PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。默认情况下队列中的元素采取自然顺序排序，也可以通过比较器comparator来指定元素的排序规则。
	- DelayQueue：一个使用优先级队列PriorityBlockingQueue实现的无界阻塞队列，是一个支持延时获取元素的队列。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取元素，只有在延迟期满时才能从队列中提取元素。
	- SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。
	- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。**transfer方法**：如果当前由消费者正在等待接收元素，transfer可以把生产者传入的元素立刻transfer给消费者。如果没有消费者正在等待，transfer方法会将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。**tryTransfer方法**：是用来试探生产者传入的元素是否能直接传给消费者，如果没有消费者在等待，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接受，方法立即返回，而transfer方法是必须等到消费者消费了才返回。
	- LinkedBlockingDeque：一个由链表结构组成的**双向阻塞队列**。
### List
- ArrayList：底层是动态数组。
- LinkedList：底层是双向链表。
- Vector：线程安全的动态数组。
### Map
- HashMap：底层是散列表。
- ConcurrentHashMap：线程安全的。
- HashTable：线程安全的。
- TreeMap：实现了SortedMap接口，能够把它保存的记录根据键值排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。
- LinkedHashMap：是HashMap的子类，LinkedHashMap中的遍历可分为插入顺序和访问顺序两种，底层维护了一个双向链表用来保存元素的顺序。构造方法中的accessOrder默认为为false，表示LinkedHashMap中存储的元素是按照调用put方法插入的顺序进行排序的，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。
- 一般情况下，我们用的最多的是HashMap。HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map中插入、删除和定位元素，HashMap 是最好的选择。TreeMap取出来的是排序后的键值对，如果要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。LinkedHashMap是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现。它还可以按读取顺序来排列，像连接池中可以应用。
### Set
- HashSet：底层是HashMap，不能保证元素的顺序。允许null值。HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hash值作为标识的。
- TreeSet：底层是TreeMap，可以保证元素是由顺序的。不允许null值。TreeSet的底层实现是采用红-黑树的数据结构，采用这种结构可以从Set中获取有序的序列，但是前提条件是：元素必须实现Comparable接口。

## 13、ThreadLocal类
ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有自己独立的变量。ThreadLocal采用了“以空间换时间”的方式：访问并行化，对象独享化。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。  

```java
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }

    private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }

    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }

    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    
    
```
ThreadLocal的实现原理：每个ThreadLocal的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。

```java
	static class ThreadLocalMap {

        	static class Entry extends WeakReference<ThreadLocal<?>> {
           		 /** The value associated with this ThreadLocal. */
            		Object value;

            		Entry(ThreadLocal<?> k, Object v) {
               	 		super(k);
               	 		value = v;
            		}
        	}
		
		ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
            		table = new Entry[INITIAL_CAPACITY];
            		int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
            		table[i] = new Entry(firstKey, firstValue);
            		size = 1;
            		setThreshold(INITIAL_CAPACITY);
        	}
	}
```

### ThreadLocal为什么会内存泄漏？
ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用用来引用它，那么系统GC的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref->Thread->ThreadLocalMap->Entry-value永远无法回收，造成内存泄漏。其实，ThreadLocalMap的设计中已经考虑到了这种情况，也加上了一些防护措施：在ThreadLocal的get（），set（），remove（）的时候都会清除线程ThreadLocalMap里所有key为null的value。

从表面上看内存泄漏的根源在于使用了弱引用。为什么使用弱引用而不是强引用？下面我们分两种情况讨论：
- key使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。
- key使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。
比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。

## 14、volatile关键字
[volatile关键字](https://www.cnblogs.com/dolphin0520/p/3920373.html)

## 15、IO模型
- 阻塞IO：blocking IO，当用户线程发出IO请求后，内核回去查看是否有数据就绪，如果没有数据就绪，用户线程就会处于阻塞状态，用户线程交出CPU，当数据准备好后，内核会将数据拷贝到用户线程，并返回结果给用户线程，此时用户线程解除block状态。  

- 非阻塞IO：noblocking IO，当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。  

- 信号驱动IO：signal blocking IO，在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接口几乎是没用的，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么事情。  

- 多路复用IO：IO multiplexing，java中的NIO模型。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。  

- 异步IO：asynchronous IO，异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要关心实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO，简称AIO。

前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是从内核进行数据拷贝的过程都会让用户线程阻塞。

## 16、Java中的字节流和字符流
![image](https://github.com/FantasyLakers/my-lessons/blob/master/java/java%20IO%E7%BB%93%E6%9E%84%E5%9B%BE.png?raw=true)

## 17、NIO
![image](https://github.com/FantasyLakers/my-lessons/blob/master/java/NIO%E6%A8%A1%E5%9E%8B.png?raw=true)

## 18、零拷贝 zero copy
Java的NIO为了支持零拷贝，提供了一些类：
- DirectByteBuffer：DirectByteBuffer直接在堆外分配内存，底层是直接通过JNI调用操作系统的NIO系统调用，所以性能会比较高。
- FileChannel：是Java NIO提供的用于复制文件的类，可以把文件复制到磁盘或者网络等。transferTo方法直接将当前通道内容传输到另一个通道，也就是说这种方式不会有内核缓冲区到用户缓冲区的读写问题。底层是sendfile系统调用。transferFrom方法同理。

## 19、rmi

## 20、java.security

## 21、类加载机制
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（loading），验证（verification），准备（preparation），解析（resolution），初始化（initialization），使用（using）和卸载（unloading）七个阶段。其中验证，准备和解析三个部分统称为连接（linking）。加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这就是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。  
什么情况下需要开始类加载过程的第一个阶段：加载？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把我。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
- 遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这四条指令的最常见的Java代码场景是：使用new关键字实例化队形的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先出发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化则需要先出发其父类的初始化。
- 当虚拟机启动时，当用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果时REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。  

对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：有且只有。这五种场景中的行为称为对一个类进行主动调用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。下面举三个例子来说明何为被动引用：

### 被动引用示例一：通过子类引用父类的静态字段，不会导致子类初始化
```java
/**
 * 父类 
 * 通过子类引用父类的静态字段，不会导致子类初始化
 */
public class SuperClass {

	static {
		System.out.println("I am SuperClass");
	}

	// 父类中的静态字段
	public static int value = 100;
}

/**
 * 子类
 * 通过子类引用父类的静态字段，不会导致子类初始化
 */
public class SubClass extends SuperClass{

	static {
		System.out.println("I am SubCLass");
	}
}

public class Test {

	public static void main(String[] args) {
		// 最终输出I am SuperClass  100
		System.out.println(SubClass.value);
	}

}
```

### 被动引用示例二：通过通过数组定义来引用类，不会触发此类的初始化
```java
public class SuperClass {

	static {
		System.out.println("I am SuperClass");
	}

	// 父类中的静态字段
	public static int value = 100;
}

public class Test {

	public static void main(String[] args) {
		// 不会输出父类中的I am SuperClass
		SuperClass[] sca = new SuperClass[10];
	}

}
```

### 被动引用示例三：常量在编译阶段会存入类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
```java
public class ConstClass {

	static {
		System.out.println("I am ConstClass");
	}
	
	// 常量，如果把final去掉则会触发初始化
	public static final String HELLO = "hello world";
	
}

public class Test {

	public static void main(String[] args) {
		System.out.println(ConstClass.HELLO);
	}

}
```

### 接口的加载过程
接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊声明：接口中也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块static来输出初始化信息的，而接口中不能使用static语句块，但编译器仍然会为接口生产“<clinit>()”类构造器，用于初始化接口中定义的成员变量。接口与类真正有所区别的是前面讲述的五种有且仅有需要开始初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不需要其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

## 22、类加载的过程---加载、验证、准备、解析和初始化
- 加载：加载时类加载过程的一个阶段，希望大家没有混淆这两个名词。在加载阶段，虚拟机需要完成以下三件事情
	- 通过一个类的全限定名来获取定义此类的二进制字节流
	- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口  
- 连接：加载阶段与连接阶段的部分内容，如一部分字节码文件格式验证动作时交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。
- 验证：验证时连接阶段的第一步，这一阶段的目的时为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致会完成下面四个动作
	- 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，这一阶段可能包含下面这些验证点：是否以魔数0xCAFEBABE开头，主、次版本号是否再当前虚拟机的处理范围内，常量池的常量是否有不被支持的常量类型，指向常量的各种索引值中是否有不存在的常量或不符合类型的常量，CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据，Class文件中各个部分及文件本身是否有被删除的或附加的信息。
	- 元数据验证：第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范。这个阶段可能包括的验证点如下：这个类是否有父类（除了Object类之外，所有的类都应该有父类），这个类的父类是否继承了不被允许继承的类（被final修饰的类），如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法，类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）
	- 字节码验证：第三阶段时整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的**方法体**进行校验分析，例如：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，保证跳转指令不会跳转到方法体以外的字节码指令上，保证方法体中的类型转换是有效的。
	- 符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段---解析中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验以下内容：符号引用中通过字符串描述的全限定名是否能找到对应的类，在指定的类中是否存在方法的字段描述符以及简单名称所描述的方法和字段，符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可以被当前类访问
- 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里说的初始值“通常情况”下会是数据类型的零值，假设一个类变量的定义为
```java
	public static int value = 123;
```
那变量value在准备阶段过后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所有把value赋值为123的动作将在初始化阶段才会执行。在通常情况下初始值是零值，那相对的就有一些“特殊情况”，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为
```java
	public static final int value = 123;
```
编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123.
- 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用进行。
	- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。
	- 直接引用：直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。
- 初始化：	

## 23、动态代理

## 24、java8中ConcurrentHashMap的变化
[Java8之前ConcurrentHashMap的原理分析](https://blog.csdn.net/jiahao1186/article/details/83689241)
[Java8中的ConcurrentHashMap的原理分析](https://blog.csdn.net/u010723709/article/details/48007881)

## 25、java8中HashMap的变化
[Java8和Java7中HashMap的变化](https://www.cnblogs.com/jajian/p/10385063.html)

## 26、什么是AQS
[AQS的全称是AbstractQueuedSynchronizer：抽象队列同步器。](https://www.cnblogs.com/waterystone/p/4920797.html)

## 27、反射
