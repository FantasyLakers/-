# Java知识点

## 1、注解
- @Rentention：保留策略  
	- @Rentention(RententionPolicy.SOURCE)：编译器要丢弃的注释  
	- @Rentention(RententionPolicy.CLASS)：编译器把注释记录在类文件中，但在运行时不需要保留注释  
	- @Rentention(RententionPolicy.RUNTIME)：编译器把注释记录在类文件中，在运行时刻通过反射来获取  
- @Target：注解的目标对象 
	- ANNOTATION_TYPE：标注注释类型    
	- METHOD：标注方法  
	- CONSTRUCTOR：标注构造方法  	      
	- PACKAGE：标注包  
	- FIELD：标注字段  	      
	- PARAMETER：标注参数  
	- LOCAL_VARIABLE：标注局部变量  
	- TYPE：标注类、接口（包括注释类型）或枚举声明
- @DOCUMENTED
	- 如果类型声明是用Documented来注释的，则其注释将成为注释元素的公共API的一部分。
	
## 2、线程状态
- 新建
- 可运行
- 运行
- 阻塞/等待/睡眠
- 终止

## 3、synchronized
synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：
- 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
- 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
- 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；

## 4、ReentrantLock
当系统处于高并发状态时，可以使用ReentrantLock来提高性能。
```java
	class X {
   		private final ReentrantLock lock = new ReentrantLock();

   		public void m() { 
     			lock.lock();  // block until condition holds
     			try {
       				// ... method body
     			} finally {
      		 		lock.unlock()
     			}
   		}	
	 }
```

### ReentrantLock和synchronized的比较
- ReentrantLock功能性方面更全面，比如时间锁等候，可中断锁等候，锁投票等，因此更有扩展性。在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。
- ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错。
- ReentrantLock 的性能比synchronized会好点。
- ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。
- Lock的某些方法可以决定多长时间内尝试获取锁，如果获取不到就抛异常，这样就可以一定程度上减轻死锁的可能性。
如果锁被另一个线程占据了，synchronized只会一直等待，很容易错序死锁 
- synchronized的话，锁的范围是整个方法或synchronized块部分；而Lock因为是方法调用，可以跨方法，灵活性更大 

## 5、线程池 ThreadPoolExecutor
maximumPoolSize：线程池最大线程数量。  
keepAliveTime：线程没有任务执行时最多保持多久会终止。  
unit：keepAliveTime的单位，参见枚举类TimeUnit  
corePoolSize：池中所保存的线程数，包括空闲线程  
workQueue：一个阻塞队列，用来存储等待执行的任务，此队列仅保持由execute方法提交的Runnable任务  
threadFactory：执行程序创建新线程使用的工厂  
handler：由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序  

jdk官方文档中建议使用Executors工厂方法来创建线程池。
- Executors.newCachedThreadPool：无界线程池，可以进行自动线程回收。适用于执行大量耗时小的任务   
- Executors.newFixedThreadPool：线程数量固定的线程池，即只有核心线程，可以更快的响应外界请求
- Executors.newSingleThreadPool：单个后台线程
- Executors.newScheduledThreadPool：核心线程数量是固定的，非核心线程数量是不固定的，当非核心线程闲置时他会被立即回收。主
要用于执行定时任务和具有固定时期的重复任务。

## 6、四种引用--可以让程序员通过代码的方式决定某些对象的生命周期；有利于JVM进行垃圾回收。
- **强引用**：指创建一个对象并把这个对象赋给一个引用变量。
	```java
	Object obj = new Object(); // 只要引用存在，垃圾回收器永远不会回收，只有当obj被这个引用被释放掉之后，对象才会被释放掉
	```

- **软引用SoftReference**：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收他。如果内存空间不足，就会被回收。软引用可以
和引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收了，java虚拟机就会把这个软引用加入到与之关联的引用队列中。
	```java
	Object obj = new Object();
	SoftReference<Object> sf = new SoftReference<Object>(obj);
	obj = null;
	sf.get(); // 有时会返回null
	```
这个时候sf是对obj的软引用，通过sf.get()方法可以去到这个对象，当然，当这个对象被标记为需要回收的对象时，会返回null。软应用主要用来实现类似缓存的功能，在内存足够的时候，直接通过软引用取值，无需从繁忙的真实来源取值，提升性能。当内存不足时，自动删除这些缓存数据，再从真实来源查询这些数据。

- **弱引用WeakReference**：弱引用也是用来描述非必须对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱
引用可以和引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收了，java虚拟机就会把这个弱引用加入到与之关联的引用队列
中。
	```java		
	Object obj = new Object();
	WeakReference<Object> wf = new WeakReference<Object>(obj);
	obj = null;
	wf.get(); // 有时会返回null
	wf.isEnQueued(); // 返回是否被垃圾回收器标记为即将回收的垃圾。
	```

- **虚引用PhantomReference**：虚引用不影响对象的生命周期，如果一个对象和虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用对象的内存被回收之前采取必要的行动。
	```java
	Object obj = new Object();
	PhantomReference<Object> pf = new PhantomReference<Object>(obj);
	obj = null;
	pf.get(); // 永远返回null
	pf.isEnQueued();
	```

补充说明：在任何时候我们都可以调用ReferenceQueue的Poll()方法来检查是否有他所关心的非强可及对象被回收。如果队列为空，则返回一个null，否则返回队列中前面的一个Reference对象。


## 7、位运算符
- 按位与 & ：同时为1则为1，否则为0
- 按位或 |：只要一个为1，则为1
- 异或  ^ ：两个相应位值不同，则为1，否则为0
- 右移运算符：>>，右移相当于除以2的N次方，舍弃余数，符号位也会移动，左补0或1，看是正数还是负数
- 左移运算符：<<，左移相当于乘以2的N次方
- 无符号右移运算符：>>>

## 8、虚拟机参数
-Xms：虚拟机堆区内存初始内存大小，通常为操作系统可用内存的1/64大小即可。-Xms1024m    
-Xmx：虚拟机堆区内存最大内存大小，通常为操作系统可用内存的1/4大小。-Xmx2048m    
-XX:MinHeapFreeRatio：设置堆空间的最小空间比例。当堆空间的空闲内存小于这个数值时，jvm便会扩展堆空间  
-XX:MaxHeapFreeRatio：设置堆空间的最大空间比例。当堆空间的空闲内存大于这个数值时，jvm便会缩小堆空间  
-XX:PermSize：表示非堆区初始内存分配大小，即永久区。-XX:PermSize=256m    
-XX:MaxPermSize：表示对非堆区分配的内存的最大上限。-XX:MaxPermSize=512m    
-Xss：设置线程栈的大小  
-XX:NewSize=n 设置年轻代大小  
-XX:NewRatio=n 设置年轻代和年老代的比例。假如值为3，表示年轻代和年老代比值为1:3  
-XX:+PrintGCDetails：打印gc日志  
-XX:+PrintHeapAtGC：在gc前后，都输出详细的堆信息         

## 9、垃圾收集算法
### 如何判断对象是否还存活
- 引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减一。但是对象之间相互循环引用会导致该算法出现问题。
- 可达性分析算法：这个算法的基本思路是通过一系列的称之为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。在java中，可作为GC Roots的对象包括虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常亮引用的对象、本地方法栈中JNI（即Native方法）引用的对象。
### 收集算法
- 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。不足之处在于 1、效率问题，标记和清除的两个过程效率都不太高 2、空间问题  标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
- 复制算法：将可用内存按容量划分为等量的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法现在大多用来清理新生代。由于新生代朝生夕死，所以将内存分为一个较大的Eden区域和两块较小的Survivor区域，当回收时，将Eden和Survivor上存活的对象复制到另一块Survivor中，然后清理Eden和Survivor，当Survivor空间不足时，需要将某些新生代通过分配担保机制进入老年代。
- 标记-整理算法：类似于标记清除算法，标记完成后将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
- 分代收集算法：将对象分为新生代和老年代，在新生代中，每次垃圾收集时都有大批对象死去，就选用复制算法。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记清理或标记整理算法进行回收。

## 10、java内存区域
- 程序计数器：是一块较小的内存空间，它可以看成是当前线程所执行的字节码的行号指示器。每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。该内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
- java虚拟机栈（Stack）：和程序计数器一样是线程私有的，它的生命周期和线程相同。每个方法在执行的同时会创建一个栈帧用语存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型(int/short/float/long/double/boolean/char/byte)、对象引用。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverfolwError异常，如果虚拟机允许动态扩展，但无法申请到足够的内存，将抛出OutOfMemeroyError异常。
- 本地方法栈：和虚拟机栈类似，本地方法栈用于执行Native方法。
- java堆(Heap)：java堆是被所有线程共享的内存区域，几乎所有的对象实例和数组都要在堆上分配
- 方法区(永久代)：和java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 运行时常量池：是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

## 11、Java设计原则
- 单一原则一个类只负责一项职责。
- 里氏替换原则
	* 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
	* 子类中可以增加自己特有的方法
	* 当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松
	* 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格
- 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。例如有一个方法tellStory，它的参数为Book实体类，而不是接口或抽象类，这是不应该的。
	```java
	public void tellStory(Book book){
		// tellStory
	}
	```
- 接口隔离原则：客户端不应该依赖他不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上
- 迪米特法则（最少知道原则）：一个类要尽量的封装自己，一个类只与自己的朋友类打交道（朋友类：朋友类是成员变量或者方法参数，非朋友类一般都是局部变量）
- 开闭原则：对扩展开放，对修改闭合

## 12、java.util包和java.util.concurrent包下的关键类和接口
### Queue：队列是一个先进先出的（FIFO）的数据结构。常用的并发队列有阻塞队列和非阻塞队列，前者使用锁实现，后者则使用CAS非阻塞算法实现。
- 非阻塞队列：
	- LinkedList：一个由链表结构组成的双向队列。
	- PriorityQueue：一个由数组结构组成的基于优先级的无界优先级队列。
	- ConcurrentLinkedQueue：一个采用链表实现的无界非阻塞**线程安全**队列。
- 阻塞队列（继承BlockingQueue）
	- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。
	- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。
	- PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。默认情况下队列中的元素采取自然顺序排序，也可以通过比较器comparator来指定元素的排序规则。
	- DelayQueue：一个使用优先级队列PriorityBlockingQueue实现的无界阻塞队列，是一个支持延时获取元素的队列。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取元素，只有在延迟期满时才能从队列中提取元素。
	- SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。
	- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。**transfer方法**：如果当前由消费者正在等待接收元素，transfer可以把生产者传入的元素立刻transfer给消费者。如果没有消费者正在等待，transfer方法会将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。**tryTransfer方法**：是用来试探生产者传入的元素是否能直接传给消费者，如果没有消费者在等待，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接受，方法立即返回，而transfer方法是必须等到消费者消费了才返回。
	- LinkedBlockingDeque：一个由链表结构组成的**双向阻塞队列**。
### List
- ArrayList：底层是动态数组。
- LinkedList：底层是双向链表。
- Vector：线程安全的动态数组。
### Map
- HashMap：
- ConcurrentHashMap：
- HashTable：
- TreeMap：
- LinkedHashMap：
### Set
- HashSet：
- TreeSet：

## 13、ThreadLocal类

## 14、volatile关键字

## 15、IO

## 16、NIO

## 17、反射

## 18、rmi

## 19、java.security

## 20、类加载机制
