# spring相关

## 1、spring编程式事务
spring支持声明式事务和编程式事务。编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager，对于编程式事务，spring推荐使用TransactionTemplate。声明式事务基于AOP，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据实际情况提交或者回滚事务。声明式事务最大的特点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明（或通过基于@Transactional注解的方式），便可以将事务规则应用到业务逻辑中。
编程式事务实例：
```java
	transactionTemplate.execute(new TransactionCallback() {
		public Object doInTransaction(TransactionStatus status) {
			// TODO
		}
	});
```

## 2、事务的传播机制
- REQUIRED：如果当前没事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。
- SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。
- MANDATORY：使用当前的事务，如果当前没事务，就抛出异常。
- REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。
- NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
- NESTED：如果当前存在事务，则在嵌套事务内执行，如果当前没事务，则执行与REQUIRED类似的操作。

## 3、声明式事务
声明式事务有两种常见的方式，一种是基于tx和aop命名空间的xml配置方式，另一种是基于@Transactional注解。@Transactional可以作用于接口，接口方法，类以及类方法上，当作用于类上时，该类的所有public方法都将具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义，@Transactional注解应该只被应用到public方法上，spring建议不要在接口和接口方法中使用@Transactional注解。

**@Transactional中包含的属性**
- value:可选的限定描述符，指定使用的事务管理器
- propagation：可选的事务传播行为设置
- isolation：可选的事务隔离级别设置
- readOnly：读写或只读事务，默认读写
- timeout：事务超时时间设置
- rollbackFor、rollbackForClassName：导致事务回滚的异常类数组
- norollbackFor、noRollbackForClassName：不会导致事务回滚的异常类名数组

```java
	//@Transactional示例，配置中需声明<tx:annotation-driven transaction-manager="transactionManager" />
	@Transactional(propagation=Propagation.NOT_SUPPORTED , rollbackfor=RuntimeException.class)
	public class CifService{
	
	}
```

## 4、事务的隔离级别
- ISOLATION_DEFAULT：表示使用底层数据库的默认隔离级别。
- ISOLATION_UNCOMMITED：该隔离级别表示一个事务可以读取另一个事务修改但是未提交的数据。
- ISOLATION_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据，该级别可以防止脏读。
- ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以重复执行某个查询，并且每次返回的记录都相同，该级别可以防止脏读和不可重复读。
- ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。

## 5、spring定时器
有两种格式：秒，分，时，天，月，星期几 ,年 或者 秒，分，时，天，月，星期几

```xml
	<!-- 定时器配置 -->
	<bean id="timeDitail"  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
		<property name="targetObject" ref="myTimer"></property><!-- 指定任务类 -->
		<property name="targetMethod" value="doit"></property><!-- 指定任务方法 -->
	</bean>

	<!-- 定义时间间隔触发器 -->
	<bean id="timeTigger" class="org.springframework.scheduling.quartz.CronTriggerBean">
		<property name="jobDetail" ref="timeDitail"></property>
		<property name="cronExpression"><value>*/5 * * * * ?</value></property>
	</bean>

	<!-- 启动定时器 -->
	<bean id="startJob"  class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
		<property name="triggers">
			<list>
				<ref bean="timeTigger" />
			</list>
		</property>
	</bean>
```

## 6、spring常用注解
- 注入类注解
	- @Resource：默认按照名称来匹配
	- @Autowired：默认按照类型来匹配，当和@Qualifier一起用时，则从byType转变为byName
```java
	@Autowired
	@Qualifier("userService")
	private UserService userService;
```

- 声明类注解
	- @Service：用于标注业务层组件
	- @Controller：用于标注控制层组件
	- @Repository：用于标注数据访问组件
	- @Component：泛指组件，当组件不好归类时，可使用该组件

## 7、bean的作用域
- scope="singleton"：默认作用域，spring容器中只存在一个共享的bean实例
- scope="prototype"：每一次请求都会产生一个新的bean实例
- scope="request"：request表示每次http请求都会产生一个新的bean，同时该bean仅在当前http request中有效
- scope="session"：seeion作用域表示每一次请求都会产生一个新的bean，同时该bean仅在当前http session中有效
- scope="global session"
- 自定义scope：实现Scope接口

## 8、IOC
[IOC源码解读](https://javadoop.com/post/spring-ioc)

## 9、AOP
[AOP原理](https://blog.csdn.net/blogdevteam/article/details/103045864)

## 10、Spring如何解决循环依赖？

Spring的bean的初始化主要分为三步：

- 实例化createBeanInstance：调用构造方法实例化对象
- 填充属性populateBean：对bean的依赖属性进行填充
- 初始化initializeBean：调用bean的init()方法

从上面的步骤可以得知，循环依赖主要发生在第一和第二步，也就是构造器循环依赖和filed循环依赖。

### 构造器依赖

Spring无法解决构造器依赖问题

### singleton属性循环依赖

spring为了解决单例的循环依赖问题，使用了三级缓存，这三级缓存分别指：

- singletonObjects：单例对象的缓存
- singletonFactories：单例对象工程的缓存
- earlySingletonObjects：提前曝光的单例对象的缓存

```java
/** 详见DefaultSingletonBeanRegistry类  */
/** Cache of singleton objects: bean name --> bean instance */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);

/** Cache of singleton factories: bean name --> ObjectFactory */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);

/** Cache of early singleton objects: bean name --> bean instance */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);

@Override
public Object getSingleton(String beanName) {
    return getSingleton(beanName, true);
}

protected Object getSingleton(String beanName, boolean allowEarlyReference) {
	Object singletonObject = this.singletonObjects.get(beanName);
	if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
		synchronized (this.singletonObjects) {
			singletonObject = this.earlySingletonObjects.get(beanName);
			if (singletonObject == null && allowEarlyReference) {
				ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
				if (singletonFactory != null) {
					singletonObject = singletonFactory.getObject();
					this.earlySingletonObjects.put(beanName, singletonObject);
					this.singletonFactories.remove(beanName);
				}
			}
		}
	}
	return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
```

spring首先从一级缓存singletonObjects中获取，如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()获取。

## 11、Spring bean生命周期


## 12、Spring Cloud主要组件

### Eureka 服务注册和发现组件

分成两类，一是注册中心及EurekaServer，用于提供服务注册、服务申请等功能。另一个是被注册者及服务提供者EurekaClient，用于向EurekaServer注册服务并可从EurekaServer获取需要调用的服务地址信息。需要向外提供服务的应用，需要使用EurekaClient来想Server注册服务。

### Ribbon 负载均衡组件

负责进行客户端负载均衡的组件，一般与RestTemplate结合，在访问EurekaClient提供的服务时进行负载均衡处理。也就是说，Ribbon用于服务调用者向被调用者进行服务调用，并且如果服务者有多个节点时，会进行客户端的负载均衡处理。

### Feign 声明式远程调度

与Ribbon功能类似，用于调用方与被调用方的服务调用，同时进行负载均衡的处理；不过它能提供类似本地调用的方式调用远程的EurekaClient提供的服务；它实际上在Ribbon基础上进行了进一步的封装来提供调用服务的简便性。

### Hystrix 熔断组件

Hystrix是一个熔断组件，它除了一些基本的熔断器功能外，还能够实现服务降级、服务限流的功能。另外Hystrix提供了熔断器的健康监测，以及熔断器健康数据的API接口。Hystrix Dashboard组件提供了单个服务熔断器的健康状态数据的界面展示功能，Hystrix Turbine组件提供了多个服务的熔断器的健康状态数据的界面展示功能。

### Zuul 路由网关

路由网关Zuul有智能路由和过滤的功能。内部服务的API接口通过Zuul网关统一对外暴露，内部服务的API接口不直接暴露，防止了内部服务敏感信息对外暴露。Zuul的过滤功能是通过拦截请求来实现的，可以对一些用户的角色和权限进行判断，起到安全验证的作用，同时也可以用于输出实时的请求日志。

### Spring Cloud Config 配置中心

Spring Cloud Config组件提供了配置文件统一管理的功能。Spring Cloud Config包括Server端和Client端，Server端读取本地仓库或者远程仓库的配置文件，所有的Client从Server读取配置信息，从而达到配置文件统一管理的目的。

### Spring Cloud Bus 消息总线

消息总线，配置Spring Cloud Config用于动态刷新服务的配置
