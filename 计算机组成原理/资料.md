# 计算机组成原理

## 1、原码----原码的设计不便于加减运算
最高位表示符号位  
例如 0 = 0000 0000 ， -0 = 1000 0000  
例如 1 = 0000 0001  ，-1 = 1000 0001  
例如 5 = 0000 0101  ， -5 = 1000 0101  

## 2、反码----反码的设计也不便于加减运算
正数的反码是其本身，负数的反码是在其原码基础上，符号位不变，其他位按位取反  
例如 0 = 0000 0000 ， -0 = 1111 1111  
例如 1 = 0000 0001 ， -1 = 1111 1110  
例如 5 = 0000 0101  ， -5 = 1111 1010  

## 3、补码
正数的补码是其本身，负数的补码是在其原码基础上，符号位不变，其他位按位取反，最后加一，即在反码的基础上加一。补码没有正0与负0之分，都是0000 0000。  
计算机中正数用原码表示，负数用补码表示，且计算机只用加法器来计算加减法。  
例如 1 = 0000 0001 ， -1 = 1111 1111  
例如 5 = 0000 0101  ， -5 = 1111 1011  

## 4、内存

## 5、Linux中的用户空间和内核空间
- 用户空间（User Space）：应用程序的运行空间
- 内核空间（Kernel Space）：内核的运行空间，操作系统和驱动程序运行在内核空间。    

内核态和用户态有自己的内存映射，即自己的地址空间。为了安全，用户空间和内核空间是隔离的，即使用户的进程崩溃了，也不影响内核。正是有了不同运行状态的划分，才有了上下文的概念。用户空间的应用程序，如果想要请求系统服务，比如操作一个物理设备，或者映射一段设备空间的地址到用户空间，就必须通过系统调用来(操作系统提供给用户空间的接口函数)实现。  
通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及到上下文的切换，用户空间和内核空间具有不同的地址映射，通用或专用的寄存器组，而用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执行，所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。

## 6、从一个文件中读出并将数据传到另一台服务器上的流程
### File.read(file , buf , len)
- 应用程序中调用read方法，这里会涉及到一次上下文切换（用户态-->内核态），底层采用DMA（direct memory access）读取磁盘的文件，并把内容存储到内核地址空间的读取缓存区。
- 由于应用程序无法访问内核地址空间的数据，如果应用程序要操作这些数据，得把这些内容从内核的读取缓冲区拷贝到用户缓冲区。read调用的返回引发一次上下文切换（内核态-->用户态），现在数据已经被拷贝到了用户的地址空间缓冲区，如果有需要，可以修改这些内容。

### Socket.send(socket , buf , len)
- 我们最终的目的是把这个文件内容通过socket传到另一个服务器，调用socket的send方法，又涉及到一次上下文切换（用户态-->内核态），同时，文件内容被进行第三次拷贝，这次的缓冲区与目标套接字相关联，与读取缓冲区无关。
- send调用返回，引发第四次的上下文切换，同时进行第四次拷贝，DMA把数据从目标套接字相关的缓存区传到协议引擎进行发送。  

整个过程中，过程1和4是由DMA负责，并不会消耗CPU，只有过程2和3的拷贝需要CPU参与。如果在应用程序中，不需要操作内容，过程2和3显然是多余的，如果可以直接把内核态读取缓存区数据直接拷贝到套接字相关的缓存区，则上下文切换的次数从四次减少到了两次，拷贝次数从四次减少到了三次（其中DMA copy两次，CPU copy一次）。  
在Linux内核2.4及后期版本中，针对套接字缓冲区描述符做了相应调整，DMA自带了收集功能。

## 7、Page Cache
Page cache是通过将磁盘中的数据缓存到内存中，从而减少磁盘I/O操作，从而提高性能。此外，还要确保在page cache中的数据更改时能够被同步到磁盘上，后者被称为page回写（page writeback）。对磁盘的数据进行缓存从而提高性能主要是基于两个因素：第一，磁盘访问的速度比内存慢好几个数量级（毫秒和纳秒的差距）。第二是被访问过的数据，有很大概率会被再次访问。  
Page cache由内存中的物理page组成，其内容对应磁盘上的block。page cache的大小是动态变化的，可以扩大，也可以在内存不足时缩小。cache缓存的存储设备被称为后备存储（backing store），注意我们在block I/O一文中提到的：一个page通常包含多个block，这些block不一定是连续的。  

- 读Cache：当内核发起一个读请求时（例如进程发起read()请求），首先会检查请求的数据是否缓存到了page cache中，如果有，那么直接从内存中读取，不需要访问磁盘，这被称为cache命中（cache hit）。如果cache中没有请求的数据，即cache未命中（cache miss），就必须从磁盘中读取数据。然后内核将读取的数据缓存到cache中，这样后续的读请求就可以命中cache了。page可以只缓存一个文件部分的内容，不需要把整个文件都缓存进来。
- 写Cache：当内核发起一个写请求时（例如进程发起write()请求），同样是直接往cache中写入，后备存储中的内容不会直接更新。内核会将被写入的page标记为dirty，并将其加入dirty list中。内核会周期性地将dirty list中的page写回到磁盘上，从而使磁盘上的数据和内存中缓存的数据一致。
- Cache回收：Page cache的另一个重要工作是释放page，从而释放内存空间。cache回收的任务是选择合适的page释放，并且如果page是dirty的，需要将page写回到磁盘中再释放。下面先介绍LRU算法，然后介绍基于LRU改进的Two-List策略，后者是Linux使用的策略。
  - LRU算法：LRU（least rencently used)最近最少使用算法是选择最近一次访问时间最靠前的page，即干掉最近没被光顾过的page。原始LRU算法存在的问题是，有些文件只会被访问一次，但是按照LRU的算法，即使这些文件以后再也不会被访问了，但是如果它们是刚刚被访问的，就不会被选中。
  - Two-List策略：Two-List策略维护了两个list，active list 和 inactive list。在active list上的page被认为是hot的，不能释放。只有inactive list上的page可以被释放的。首次缓存的数据的page会被加入到inactive list中，已经在inactive list中的page如果再次被访问，就会移入active list中。两个链表都使用了伪LRU算法维护，新的page从尾部加入，移除时从头部移除，就像队列一样。如果active list中page的数量远大于inactive list，那么active list头部的页面会被移入inactive list中，从而位置两个表的平衡。  

[原文链接](https://blog.csdn.net/damontive/article/details/80552566)

## 8、字符编码
- ASCII码：我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。**这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。**  

- 非ASCII编码：英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，**利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。**这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。 

- Unicode：Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从0x000000 到 0x10FFFF (十六进制)，有 110 多万，每个字符都有一个唯一的 Unicode 编号，这个编号一般写成 16 进制，在前面加上 U+。需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，**却没有规定这个二进制代码应该如何存储**。比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。这里就有两个严重的问题：
  - 第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？
  - 第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。  
  
- UTF-8：**UTF-8是Unicode 的实现方式之一**。UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8 的编码规则很简单，只有两条：
  - 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。
  - 对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode码。  
  - 举个例子：比如说一个字符的 Unicode 编码是 130，显然按照 UTF-8 的规则一个字节是表示不了它（因为如果是一个字节的话前面的一位必须是0），所以需要两个字  节(n = 2)。根据规则，第一个字节的前 2 位都设为 1，第 3(2+1) 位设为 0，则第一个字节为：110X XXXX，后面字节的前两位一律设为 10，后面只剩下一个字节，所以后面的字节为：10XX XXXX。所以它的格式为 110XXXXX 10XXXXXX。那么对于一个具体的 Unicode 编号，具体怎么进行 UTF-8 的编码呢？首先找到该 Unicode 编号所在的编号范围，进而可以找到与之对应的二进制格式，然后将该 Unicode 编号转化为二进制数（去掉高位的 0），最后将该二进制数从右向左依次填入二进制格式的 X 中，如果还有 X 未填，则设为 0 。比如：“马”的 Unicode 编号是：0x9A6C，整数编号是 39532，对应第三个范围（2048 - 65535），其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532 对应的二进制是 1001 1010 0110 1100，将二进制填入进入就为： 11101001 10101001 10101100 。
  
- UTF-32：这个就是字符所对应编号的整数二进制形式，四个字节。这个就是直接转换。 比如马的 Unicode 为：U+9A6C，那么直接转化为二进制，它的表示就为：1001 1010 0110 1100。UTF-32 用四个字节表示，处理单元为四个字节（一次拿到四个字节进行处理），如果不分大小端的话，那么就会出现解读错误，比如我们一次要处理四个字节 12 34 56 78，这四个字节是表示 0x12 34 56 78 还是表示 0x78 56 34 12？不同的解释最终表示的值不一样。我们可以根据他们高低字节的存储位置来判断他们所代表的含义，所以在编码方式中有 UTF-32BE 和 UTF-32LE，分别对应大端和小端，来正确地解释多个字节（这里是四个字节）的含义。 

- UTF-16：同样，UTF-16 也有字节的顺序问题（大小端），所以就有 UTF-16BE 表示大端，UTF-16LE 表示小端。UTF-16使用变长字节表示：
  - 对于编号在 U+0000 到 U+FFFF 的字符（常用字符集），直接用两个字节表示。 
  - 编号在 U+10000 到 U+10FFFF 之间的字符，需要用四个字节表示。
  
## 9、大小端
